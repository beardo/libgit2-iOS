extern void test_refs_normalize__can_normalize_a_direct_reference_name(void);
extern void test_refs_normalize__cannot_normalize_any_direct_reference_name(void);
extern void test_refs_normalize__symbolic(void);
extern void test_refs_normalize__jgit_suite(void);
extern void test_refs_normalize__buffer_has_to_be_big_enough_to_hold_the_normalized_version(void);
extern void test_refs_normalize__refspec_pattern(void);
extern void test_repo_pathspec__workdir0(void);
extern void test_repo_pathspec__workdir1(void);
extern void test_repo_pathspec__workdir2(void);
extern void test_repo_pathspec__workdir3(void);
extern void test_repo_pathspec__workdir4(void);
extern void test_repo_pathspec__index0(void);
extern void test_repo_pathspec__index1(void);
extern void test_repo_pathspec__tree0(void);
extern void test_repo_pathspec__tree5(void);
extern void test_repo_pathspec__in_memory(void);
extern void test_repo_pathspec__initialize(void);
extern void test_repo_pathspec__cleanup(void);
extern void test_odb_alternates__chained(void);
extern void test_odb_alternates__long_chain(void);
extern void test_odb_alternates__cleanup(void);
extern void test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_file_located_in_the_working_directory(void);
extern void test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_absolute_filepath_pointing_outside_of_the_working_directory(void);
extern void test_object_blob_write__can_create_a_blob_in_a_bare_repo_from_a_absolute_filepath(void);
extern void test_object_blob_write__cleanup(void);
extern void test_core_posix__inet_pton(void);
extern void test_core_posix__initialize(void);
extern void test_threads_basic__cache(void);
extern void test_threads_basic__multiple_init(void);
extern void test_threads_basic__initialize(void);
extern void test_threads_basic__cleanup(void);
extern void test_core_env__0(void);
extern void test_core_env__1(void);
extern void test_core_env__2(void);
extern void test_core_env__initialize(void);
extern void test_core_env__cleanup(void);
extern void test_odb_backend_nonrefreshing__exists_is_invoked_once_on_failure(void);
extern void test_odb_backend_nonrefreshing__read_is_invoked_once_on_failure(void);
extern void test_odb_backend_nonrefreshing__readprefix_is_invoked_once_on_failure(void);
extern void test_odb_backend_nonrefreshing__readheader_is_invoked_once_on_failure(void);
extern void test_odb_backend_nonrefreshing__exists_is_invoked_once_on_success(void);
extern void test_odb_backend_nonrefreshing__read_is_invoked_once_on_success(void);
extern void test_odb_backend_nonrefreshing__readprefix_is_invoked_once_on_success(void);
extern void test_odb_backend_nonrefreshing__readheader_is_invoked_once_on_success(void);
extern void test_odb_backend_nonrefreshing__read_is_invoked_once_when_revparsing_a_full_oid(void);
extern void test_odb_backend_nonrefreshing__cleanup(void);
extern void test_online_clone__network_full(void);
extern void test_online_clone__network_bare(void);
extern void test_online_clone__empty_repository(void);
extern void test_online_clone__can_checkout_a_cloned_repo(void);
extern void test_online_clone__clone_into(void);
extern void test_online_clone__custom_remote_callbacks(void);
extern void test_online_clone__cred_callback_failure_is_euser(void);
extern void test_online_clone__credentials(void);
extern void test_online_clone__bitbucket_style(void);
extern void test_online_clone__assembla_style(void);
extern void test_online_clone__can_cancel(void);
extern void test_online_clone__initialize(void);
extern void test_online_clone__cleanup(void);
extern void test_repo_getters__is_empty_correctly_deals_with_pristine_looking_repos(void);
extern void test_repo_getters__is_empty_can_detect_used_repositories(void);
extern void test_repo_getters__retrieving_the_odb_honors_the_refcount(void);
extern void test_merge_trees_modeconflict__df_conflict(void);
extern void test_merge_trees_modeconflict__initialize(void);
extern void test_merge_trees_modeconflict__cleanup(void);
extern void test_odb_loose__exists(void);
extern void test_odb_loose__simple_reads(void);
extern void test_odb_loose__permissions_standard(void);
extern void test_odb_loose__permissions_readwrite(void);
extern void test_odb_loose__initialize(void);
extern void test_odb_loose__cleanup(void);
extern void test_repo_open__bare_empty_repo(void);
extern void test_repo_open__standard_empty_repo_through_gitdir(void);
extern void test_repo_open__standard_empty_repo_through_workdir(void);
extern void test_repo_open__open_with_discover(void);
extern void test_repo_open__gitlinked(void);
extern void test_repo_open__from_git_new_workdir(void);
extern void test_repo_open__failures(void);
extern void test_repo_open__bad_gitlinks(void);
extern void test_repo_open__win32_path(void);
extern void test_repo_open__opening_a_non_existing_repository_returns_ENOTFOUND(void);
extern void test_repo_open__no_config(void);
extern void test_repo_open__force_bare(void);
extern void test_repo_open__cleanup(void);
extern void test_merge_workdir_renames__renames(void);
extern void test_merge_workdir_renames__ours(void);
extern void test_merge_workdir_renames__similar(void);
extern void test_merge_workdir_renames__initialize(void);
extern void test_merge_workdir_renames__cleanup(void);
extern void test_config_refresh__update_value(void);
extern void test_config_refresh__delete_value(void);
extern void test_config_refresh__initialize(void);
extern void test_config_refresh__cleanup(void);
extern void test_revwalk_mergebase__single1(void);
extern void test_revwalk_mergebase__single2(void);
extern void test_revwalk_mergebase__merged_branch(void);
extern void test_revwalk_mergebase__two_way_merge(void);
extern void test_revwalk_mergebase__no_common_ancestor_returns_ENOTFOUND(void);
extern void test_revwalk_mergebase__prefer_youngest_merge_base(void);
extern void test_revwalk_mergebase__no_off_by_one_missing(void);
extern void test_revwalk_mergebase__many_no_common_ancestor_returns_ENOTFOUND(void);
extern void test_revwalk_mergebase__many_merge_branch(void);
extern void test_revwalk_mergebase__initialize(void);
extern void test_revwalk_mergebase__cleanup(void);
extern void test_merge_workdir_setup__one_branch(void);
extern void test_merge_workdir_setup__no_fastforward(void);
extern void test_merge_workdir_setup__one_oid(void);
extern void test_merge_workdir_setup__two_branches(void);
extern void test_merge_workdir_setup__three_branches(void);
extern void test_merge_workdir_setup__three_oids(void);
extern void test_merge_workdir_setup__branches_and_oids_1(void);
extern void test_merge_workdir_setup__branches_and_oids_2(void);
extern void test_merge_workdir_setup__branches_and_oids_3(void);
extern void test_merge_workdir_setup__branches_and_oids_4(void);
extern void test_merge_workdir_setup__three_same_branches(void);
extern void test_merge_workdir_setup__three_same_oids(void);
extern void test_merge_workdir_setup__remote_tracking_one_branch(void);
extern void test_merge_workdir_setup__remote_tracking_two_branches(void);
extern void test_merge_workdir_setup__remote_tracking_three_branches(void);
extern void test_merge_workdir_setup__normal_branch_and_remote_tracking_branch(void);
extern void test_merge_workdir_setup__remote_tracking_branch_and_normal_branch(void);
extern void test_merge_workdir_setup__two_remote_tracking_branch_and_two_normal_branches(void);
extern void test_merge_workdir_setup__pull_one(void);
extern void test_merge_workdir_setup__pull_two(void);
extern void test_merge_workdir_setup__pull_three(void);
extern void test_merge_workdir_setup__three_remotes(void);
extern void test_merge_workdir_setup__two_remotes(void);
extern void test_merge_workdir_setup__head_notfound(void);
extern void test_merge_workdir_setup__head_invalid_oid(void);
extern void test_merge_workdir_setup__head_foreach_nonewline(void);
extern void test_merge_workdir_setup__head_foreach_one(void);
extern void test_merge_workdir_setup__head_foreach_octopus(void);
extern void test_merge_workdir_setup__retained_after_success(void);
extern void test_merge_workdir_setup__removed_after_failure(void);
extern void test_merge_workdir_setup__initialize(void);
extern void test_merge_workdir_setup__cleanup(void);
extern void test_refs_setter__update_direct(void);
extern void test_refs_setter__update_symbolic(void);
extern void test_refs_setter__cant_update_direct_with_symbolic(void);
extern void test_refs_setter__cant_update_symbolic_with_direct(void);
extern void test_refs_setter__initialize(void);
extern void test_refs_setter__cleanup(void);
extern void test_repo_head__head_detached(void);
extern void test_repo_head__unborn_head(void);
extern void test_repo_head__set_head_Attaches_HEAD_to_un_unborn_branch_when_the_branch_doesnt_exist(void);
extern void test_repo_head__set_head_Returns_ENOTFOUND_when_the_reference_doesnt_exist(void);
extern void test_repo_head__set_head_Fails_when_the_reference_points_to_a_non_commitish(void);
extern void test_repo_head__set_head_Attaches_HEAD_when_the_reference_points_to_a_branch(void);
extern void test_repo_head__set_head_Detaches_HEAD_when_the_reference_doesnt_point_to_a_branch(void);
extern void test_repo_head__set_head_detached_Return_ENOTFOUND_when_the_object_doesnt_exist(void);
extern void test_repo_head__set_head_detached_Fails_when_the_object_isnt_a_commitish(void);
extern void test_repo_head__set_head_detached_Detaches_HEAD_and_make_it_point_to_the_peeled_commit(void);
extern void test_repo_head__detach_head_Detaches_HEAD_and_make_it_point_to_the_peeled_commit(void);
extern void test_repo_head__detach_head_Fails_if_HEAD_and_point_to_a_non_commitish(void);
extern void test_repo_head__detaching_an_unborn_branch_returns_GIT_EUNBORNBRANCH(void);
extern void test_repo_head__retrieving_an_unborn_branch_returns_GIT_EUNBORNBRANCH(void);
extern void test_repo_head__retrieving_a_missing_head_returns_GIT_ENOTFOUND(void);
extern void test_repo_head__can_tell_if_an_unborn_head_is_detached(void);
extern void test_repo_head__initialize(void);
extern void test_repo_head__cleanup(void);
extern void test_diff_pathspec__0(void);
extern void test_diff_pathspec__initialize(void);
extern void test_diff_pathspec__cleanup(void);
extern void test_submodule_status__unchanged(void);
extern void test_submodule_status__ignore_none(void);
extern void test_submodule_status__ignore_untracked(void);
extern void test_submodule_status__ignore_dirty(void);
extern void test_submodule_status__ignore_all(void);
extern void test_submodule_status__iterator(void);
extern void test_submodule_status__untracked_dirs_containing_ignored_files(void);
extern void test_submodule_status__initialize(void);
extern void test_submodule_status__cleanup(void);
extern void test_checkout_typechange__checkout_typechanges_safe(void);
extern void test_checkout_typechange__checkout_with_conflicts(void);
extern void test_checkout_typechange__initialize(void);
extern void test_checkout_typechange__cleanup(void);
extern void test_core_strmap__0(void);
extern void test_core_strmap__1(void);
extern void test_core_strmap__2(void);
extern void test_core_strmap__3(void);
extern void test_core_oidmap__basic(void);
extern void test_core_oidmap__hash_collision(void);
extern void test_refs_branches_iterator__retrieve_all_branches(void);
extern void test_refs_branches_iterator__retrieve_remote_branches(void);
extern void test_refs_branches_iterator__retrieve_local_branches(void);
extern void test_refs_branches_iterator__retrieve_remote_symbolic_HEAD_when_present(void);
extern void test_refs_branches_iterator__mix_of_packed_and_loose(void);
extern void test_refs_branches_iterator__initialize(void);
extern void test_refs_branches_iterator__cleanup(void);
extern void test_config_include__relative(void);
extern void test_config_include__absolute(void);
extern void test_config_include__homedir(void);
extern void test_config_include__refresh(void);
extern void test_config_include__ordering(void);
extern void test_config_include__depth(void);
extern void test_core_iconv__unchanged(void);
extern void test_core_iconv__decomposed_to_precomposed(void);
extern void test_core_iconv__precomposed_is_unmodified(void);
extern void test_core_iconv__initialize(void);
extern void test_core_iconv__cleanup(void);
extern void test_revwalk_simplify__first_parent(void);
extern void test_revwalk_simplify__cleanup(void);
extern void test_core_filebuf__0(void);
extern void test_core_filebuf__1(void);
extern void test_core_filebuf__2(void);
extern void test_core_filebuf__4(void);
extern void test_core_filebuf__5(void);
extern void test_core_filebuf__umask(void);
extern void test_commit_signature__leading_and_trailing_spaces_are_trimmed(void);
extern void test_commit_signature__angle_brackets_in_names_are_not_supported(void);
extern void test_commit_signature__angle_brackets_in_email_are_not_supported(void);
extern void test_commit_signature__create_empties(void);
extern void test_commit_signature__create_one_char(void);
extern void test_commit_signature__create_two_char(void);
extern void test_commit_signature__create_zero_char(void);
extern void test_diff_rename__match_oid(void);
extern void test_diff_rename__checks_options_version(void);
extern void test_diff_rename__not_exact_match(void);
extern void test_diff_rename__handles_small_files(void);
extern void test_diff_rename__working_directory_changes(void);
extern void test_diff_rename__patch(void);
extern void test_diff_rename__file_exchange(void);
extern void test_diff_rename__file_exchange_three(void);
extern void test_diff_rename__file_partial_exchange(void);
extern void test_diff_rename__rename_and_copy_from_same_source(void);
extern void test_diff_rename__from_deleted_to_split(void);
extern void test_diff_rename__rejected_match_can_match_others(void);
extern void test_diff_rename__rejected_match_can_match_others_two(void);
extern void test_diff_rename__rejected_match_can_match_others_three(void);
extern void test_diff_rename__can_rename_from_rewrite(void);
extern void test_diff_rename__case_changes_are_split(void);
extern void test_diff_rename__unmodified_can_be_renamed(void);
extern void test_diff_rename__rewrite_on_single_file(void);
extern void test_diff_rename__initialize(void);
extern void test_diff_rename__cleanup(void);
extern void test_refs_create__symbolic(void);
extern void test_refs_create__deep_symbolic(void);
extern void test_refs_create__oid(void);
extern void test_refs_create__oid_unknown(void);
extern void test_refs_create__propagate_eexists(void);
extern void test_refs_create__creating_a_reference_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_create__initialize(void);
extern void test_refs_create__cleanup(void);
extern void test_refs_lookup__with_resolve(void);
extern void test_refs_lookup__invalid_name(void);
extern void test_refs_lookup__oid(void);
extern void test_refs_lookup__namespace(void);
extern void test_refs_lookup__initialize(void);
extern void test_refs_lookup__cleanup(void);
extern void test_refs_unicode__create_and_lookup(void);
extern void test_refs_unicode__initialize(void);
extern void test_refs_unicode__cleanup(void);
extern void test_core_hex__fromhex(void);
extern void test_object_tag_peel__can_peel_to_a_commit(void);
extern void test_object_tag_peel__can_peel_several_nested_tags_to_a_commit(void);
extern void test_object_tag_peel__can_peel_to_a_non_commit(void);
extern void test_object_tag_peel__initialize(void);
extern void test_object_tag_peel__cleanup(void);
extern void test_object_raw_fromstr__fail_on_invalid_oid_string(void);
extern void test_object_raw_fromstr__succeed_on_valid_oid_string(void);
extern void test_core_string__0(void);
extern void test_core_string__1(void);
extern void test_core_string__2(void);
extern void test_core_caps__0(void);
extern void test_reset_hard__resetting_reverts_modified_files(void);
extern void test_reset_hard__cannot_reset_in_a_bare_repository(void);
extern void test_reset_hard__resetting_reverts_unmerged(void);
extern void test_reset_hard__cleans_up_merge(void);
extern void test_reset_hard__initialize(void);
extern void test_reset_hard__cleanup(void);
extern void test_object_raw_convert__succeed_on_oid_to_string_conversion(void);
extern void test_object_raw_convert__succeed_on_oid_to_string_conversion_big(void);
extern void test_object_raw_convert__convert_oid_partially(void);
extern void test_diff_drivers__patterns(void);
extern void test_diff_drivers__long_lines(void);
extern void test_diff_drivers__initialize(void);
extern void test_diff_drivers__cleanup(void);
extern void test_status_worktree__whole_repository(void);
extern void test_status_worktree__show_index_and_workdir(void);
extern void test_status_worktree__show_index_only(void);
extern void test_status_worktree__show_workdir_only(void);
extern void test_status_worktree__empty_repository(void);
extern void test_status_worktree__purged_worktree(void);
extern void test_status_worktree__swap_subdir_and_file(void);
extern void test_status_worktree__swap_subdir_with_recurse_and_pathspec(void);
extern void test_status_worktree__single_file(void);
extern void test_status_worktree__single_nonexistent_file(void);
extern void test_status_worktree__single_nonexistent_file_empty_repo(void);
extern void test_status_worktree__single_file_empty_repo(void);
extern void test_status_worktree__single_folder(void);
extern void test_status_worktree__ignores(void);
extern void test_status_worktree__issue_592(void);
extern void test_status_worktree__issue_592_2(void);
extern void test_status_worktree__issue_592_3(void);
extern void test_status_worktree__issue_592_4(void);
extern void test_status_worktree__issue_592_5(void);
extern void test_status_worktree__issue_592_ignores_0(void);
extern void test_status_worktree__issue_592_ignored_dirs_with_tracked_content(void);
extern void test_status_worktree__conflict_with_diff3(void);
extern void test_status_worktree__filemode_changes(void);
extern void test_status_worktree__interruptable_foreach(void);
extern void test_status_worktree__line_endings_dont_count_as_changes_with_autocrlf(void);
extern void test_status_worktree__line_endings_dont_count_as_changes_with_autocrlf_issue_1397(void);
extern void test_status_worktree__conflicted_item(void);
extern void test_status_worktree__file_status_honors_core_ignorecase_true(void);
extern void test_status_worktree__file_status_honors_core_ignorecase_false(void);
extern void test_status_worktree__file_status_honors_case_ignorecase_regarding_untracked_files(void);
extern void test_status_worktree__simple_delete(void);
extern void test_status_worktree__simple_delete_indexed(void);
extern void test_status_worktree__sorting_by_case(void);
extern void test_status_worktree__long_filenames(void);
extern void test_status_worktree__cleanup(void);
extern void test_object_raw_short__oid_shortener_no_duplicates(void);
extern void test_object_raw_short__oid_shortener_stresstest_git_oid_shorten(void);
extern void test_object_raw_short__oid_shortener_too_much_oids(void);
extern void test_index_reuc__add(void);
extern void test_index_reuc__add_no_ancestor(void);
extern void test_index_reuc__read_bypath(void);
extern void test_index_reuc__ignore_case(void);
extern void test_index_reuc__read_byindex(void);
extern void test_index_reuc__updates_existing(void);
extern void test_index_reuc__remove(void);
extern void test_index_reuc__write(void);
extern void test_index_reuc__cleaned_on_reset_hard(void);
extern void test_index_reuc__cleaned_on_reset_mixed(void);
extern void test_index_reuc__retained_on_reset_soft(void);
extern void test_index_reuc__cleaned_on_checkout_tree(void);
extern void test_index_reuc__cleaned_on_checkout_head(void);
extern void test_index_reuc__retained_on_checkout_index(void);
extern void test_index_reuc__initialize(void);
extern void test_index_reuc__cleanup(void);
extern void test_core_path__00_dirname(void);
extern void test_core_path__01_basename(void);
extern void test_core_path__02_topdir(void);
extern void test_core_path__05_joins(void);
extern void test_core_path__06_long_joins(void);
extern void test_core_path__07_path_to_dir(void);
extern void test_core_path__08_self_join(void);
extern void test_core_path__09_percent_decode(void);
extern void test_core_path__10_fromurl(void);
extern void test_core_path__11_walkup(void);
extern void test_core_path__12_offset_to_path_root(void);
extern void test_core_path__13_cannot_prettify_a_non_existing_file(void);
extern void test_core_path__14_apply_relative(void);
extern void test_core_path__15_resolve_relative(void);
extern void test_repo_setters__setting_a_workdir_turns_a_bare_repository_into_a_standard_one(void);
extern void test_repo_setters__setting_a_workdir_prettifies_its_path(void);
extern void test_repo_setters__setting_a_workdir_creates_a_gitlink(void);
extern void test_repo_setters__setting_a_new_index_on_a_repo_which_has_already_loaded_one_properly_honors_the_refcount(void);
extern void test_repo_setters__setting_a_new_odb_on_a_repo_which_already_loaded_one_properly_honors_the_refcount(void);
extern void test_repo_setters__initialize(void);
extern void test_repo_setters__cleanup(void);
extern void test_refs_revparse__nonexistant_object(void);
extern void test_refs_revparse__invalid_reference_name(void);
extern void test_refs_revparse__shas(void);
extern void test_refs_revparse__head(void);
extern void test_refs_revparse__full_refs(void);
extern void test_refs_revparse__partial_refs(void);
extern void test_refs_revparse__describe_output(void);
extern void test_refs_revparse__nth_parent(void);
extern void test_refs_revparse__not_tag(void);
extern void test_refs_revparse__to_type(void);
extern void test_refs_revparse__linear_history(void);
extern void test_refs_revparse__chaining(void);
extern void test_refs_revparse__upstream(void);
extern void test_refs_revparse__ordinal(void);
extern void test_refs_revparse__previous_head(void);
extern void test_refs_revparse__reflog_of_a_ref_under_refs(void);
extern void test_refs_revparse__revwalk(void);
extern void test_refs_revparse__date(void);
extern void test_refs_revparse__colon(void);
extern void test_refs_revparse__disambiguation(void);
extern void test_refs_revparse__a_too_short_objectid_returns_EAMBIGUOUS(void);
extern void test_refs_revparse__a_not_precise_enough_objectid_returns_EAMBIGUOUS(void);
extern void test_refs_revparse__issue_994(void);
extern void test_refs_revparse__try_to_retrieve_branch_before_described_tag(void);
extern void test_refs_revparse__try_to_retrieve_sha_before_branch(void);
extern void test_refs_revparse__try_to_retrieve_branch_before_abbrev_sha(void);
extern void test_refs_revparse__range(void);
extern void test_refs_revparse__parses_range_operator(void);
extern void test_refs_revparse__ext_retrieves_both_the_reference_and_its_target(void);
extern void test_refs_revparse__ext_can_expand_short_reference_names(void);
extern void test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_revision(void);
extern void test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_tree_content(void);
extern void test_refs_revparse__initialize(void);
extern void test_refs_revparse__cleanup(void);
extern void test_index_names__add(void);
extern void test_index_names__roundtrip(void);
extern void test_index_names__cleaned_on_reset_hard(void);
extern void test_index_names__cleaned_on_reset_mixed(void);
extern void test_index_names__cleaned_on_checkout_tree(void);
extern void test_index_names__cleaned_on_checkout_head(void);
extern void test_index_names__retained_on_checkout_index(void);
extern void test_index_names__initialize(void);
extern void test_index_names__cleanup(void);
extern void test_commit_parent__can_retrieve_nth_generation_parent(void);
extern void test_commit_parent__initialize(void);
extern void test_commit_parent__cleanup(void);
extern void test_object_tree_walk__0(void);
extern void test_object_tree_walk__1(void);
extern void test_object_tree_walk__2(void);
extern void test_object_tree_walk__initialize(void);
extern void test_object_tree_walk__cleanup(void);
extern void test_diff_patch__can_properly_display_the_removal_of_a_file(void);
extern void test_diff_patch__to_string(void);
extern void test_diff_patch__config_options(void);
extern void test_diff_patch__hunks_have_correct_line_numbers(void);
extern void test_diff_patch__line_counts_with_eofnl(void);
extern void test_diff_patch__initialize(void);
extern void test_diff_patch__cleanup(void);
extern void test_repo_shallow__no_shallow_file(void);
extern void test_repo_shallow__empty_shallow_file(void);
extern void test_repo_shallow__shallow_repo(void);
extern void test_repo_shallow__initialize(void);
extern void test_repo_shallow__cleanup(void);
extern void test_refs_iterator__list(void);
extern void test_refs_iterator__empty(void);
extern void test_refs_iterator__initialize(void);
extern void test_refs_iterator__cleanup(void);
extern void test_odb_sorting__basic_backends_sorting(void);
extern void test_odb_sorting__alternate_backends_sorting(void);
extern void test_odb_sorting__initialize(void);
extern void test_odb_sorting__cleanup(void);
extern void test_refs_rename__loose(void);
extern void test_refs_rename__packed(void);
extern void test_refs_rename__packed_doesnt_pack_others(void);
extern void test_refs_rename__name_collision(void);
extern void test_refs_rename__invalid_name(void);
extern void test_refs_rename__force_loose_packed(void);
extern void test_refs_rename__force_loose(void);
extern void test_refs_rename__overwrite(void);
extern void test_refs_rename__prefix(void);
extern void test_refs_rename__move_up(void);
extern void test_refs_rename__propagate_eexists(void);
extern void test_refs_rename__initialize(void);
extern void test_refs_rename__cleanup(void);
extern void test_core_rmdir__delete_recursive(void);
extern void test_core_rmdir__fail_to_delete_non_empty_dir(void);
extern void test_core_rmdir__can_skip_non_empty_dir(void);
extern void test_core_rmdir__can_remove_empty_parents(void);
extern void test_core_rmdir__initialize(void);
extern void test_core_sortedcache__name_only(void);
extern void test_core_sortedcache__in_memory(void);
extern void test_core_sortedcache__on_disk(void);
extern void test_filter_custom__to_odb(void);
extern void test_filter_custom__to_workdir(void);
extern void test_filter_custom__can_register_a_custom_filter_in_the_repository(void);
extern void test_filter_custom__order_dependency(void);
extern void test_filter_custom__filter_registry_failure_cases(void);
extern void test_filter_custom__initialize(void);
extern void test_filter_custom__cleanup(void);
extern void test_index_filemodes__read(void);
extern void test_index_filemodes__untrusted(void);
extern void test_index_filemodes__trusted(void);
extern void test_index_filemodes__initialize(void);
extern void test_index_filemodes__cleanup(void);
extern void test_refs_listall__from_repository_opened_through_workdir_path(void);
extern void test_refs_listall__from_repository_opened_through_gitdir_path(void);
extern void test_refs_listall__from_repository_with_no_trailing_newline(void);
extern void test_attr_ignore__honor_temporary_rules(void);
extern void test_attr_ignore__allow_root(void);
extern void test_attr_ignore__ignore_root(void);
extern void test_attr_ignore__skip_gitignore_directory(void);
extern void test_attr_ignore__expand_tilde_to_homedir(void);
extern void test_attr_ignore__initialize(void);
extern void test_attr_ignore__cleanup(void);
extern void test_diff_diffiter__create(void);
extern void test_diff_diffiter__iterate_files_1(void);
extern void test_diff_diffiter__iterate_files_2(void);
extern void test_diff_diffiter__iterate_files_and_hunks(void);
extern void test_diff_diffiter__max_size_threshold(void);
extern void test_diff_diffiter__iterate_all(void);
extern void test_diff_diffiter__iterate_randomly_while_saving_state(void);
extern void test_diff_diffiter__iterate_and_generate_patch_text(void);
extern void test_diff_diffiter__checks_options_version(void);
extern void test_diff_diffiter__initialize(void);
extern void test_diff_diffiter__cleanup(void);
extern void test_config_new__write_new_config(void);
extern void test_object_raw_chars__find_invalid_chars_in_oid(void);
extern void test_object_raw_chars__build_valid_oid_from_raw_bytes(void);
extern void test_repo_init__standard_repo(void);
extern void test_repo_init__standard_repo_noslash(void);
extern void test_repo_init__bare_repo(void);
extern void test_repo_init__bare_repo_noslash(void);
extern void test_repo_init__bare_repo_escaping_current_workdir(void);
extern void test_repo_init__reinit_bare_repo(void);
extern void test_repo_init__reinit_too_recent_bare_repo(void);
extern void test_repo_init__additional_templates(void);
extern void test_repo_init__detect_filemode(void);
extern void test_repo_init__detect_ignorecase(void);
extern void test_repo_init__detect_precompose_unicode_required(void);
extern void test_repo_init__reinit_doesnot_overwrite_ignorecase(void);
extern void test_repo_init__reinit_overwrites_filemode(void);
extern void test_repo_init__sets_logAllRefUpdates_according_to_type_of_repository(void);
extern void test_repo_init__extended_0(void);
extern void test_repo_init__extended_1(void);
extern void test_repo_init__extended_with_template(void);
extern void test_repo_init__extended_with_template_and_shared_mode(void);
extern void test_repo_init__can_reinit_an_initialized_repository(void);
extern void test_repo_init__init_with_initial_commit(void);
extern void test_repo_init__initialize(void);
extern void test_buf_basic__resize(void);
extern void test_buf_basic__printf(void);
extern void test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_through_the_treebuilder(void);
extern void test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_building_a_tree_from_a_index_with_conflicts(void);
extern void test_object_tree_duplicateentries__initialize(void);
extern void test_object_tree_duplicateentries__cleanup(void);
extern void test_stash_submodules__does_not_stash_modified_submodules(void);
extern void test_stash_submodules__stash_is_empty_with_modified_submodules(void);
extern void test_stash_submodules__initialize(void);
extern void test_stash_submodules__cleanup(void);
extern void test_stress_diff__rename_big_files(void);
extern void test_stress_diff__rename_many_files(void);
extern void test_stress_diff__initialize(void);
extern void test_stress_diff__cleanup(void);
extern void test_fetchhead_nonetwork__write(void);
extern void test_fetchhead_nonetwork__read(void);
extern void test_fetchhead_nonetwork__read_old_style(void);
extern void test_fetchhead_nonetwork__type_missing(void);
extern void test_fetchhead_nonetwork__name_missing(void);
extern void test_fetchhead_nonetwork__nonexistent(void);
extern void test_fetchhead_nonetwork__invalid_unterminated_last_line(void);
extern void test_fetchhead_nonetwork__invalid_oid(void);
extern void test_fetchhead_nonetwork__invalid_for_merge(void);
extern void test_fetchhead_nonetwork__invalid_description(void);
extern void test_fetchhead_nonetwork__initialize(void);
extern void test_diff_workdir__to_index(void);
extern void test_diff_workdir__to_index_with_assume_unchanged(void);
extern void test_diff_workdir__to_tree(void);
extern void test_diff_workdir__to_index_with_pathspec(void);
extern void test_diff_workdir__filemode_changes(void);
extern void test_diff_workdir__filemode_changes_with_filemode_false(void);
extern void test_diff_workdir__head_index_and_workdir_all_differ(void);
extern void test_diff_workdir__eof_newline_changes(void);
extern void test_diff_workdir__larger_hunks(void);
extern void test_diff_workdir__submodules(void);
extern void test_diff_workdir__cannot_diff_against_a_bare_repository(void);
extern void test_diff_workdir__to_null_tree(void);
extern void test_diff_workdir__checks_options_version(void);
extern void test_diff_workdir__can_diff_empty_file(void);
extern void test_diff_workdir__to_index_issue_1397(void);
extern void test_diff_workdir__to_tree_issue_1397(void);
extern void test_diff_workdir__untracked_directory_scenarios(void);
extern void test_diff_workdir__untracked_directory_comes_last(void);
extern void test_diff_workdir__untracked_with_bom(void);
extern void test_diff_workdir__patience_diff(void);
extern void test_diff_workdir__with_stale_index(void);
extern void test_diff_workdir__initialize(void);
extern void test_diff_workdir__cleanup(void);
extern void test_filter_ident__to_worktree(void);
extern void test_filter_ident__to_odb(void);
extern void test_filter_ident__initialize(void);
extern void test_filter_ident__cleanup(void);
extern void test_refs_branches_ishead__can_tell_if_a_branch_is_pointed_at_by_HEAD(void);
extern void test_refs_branches_ishead__can_properly_handle_unborn_HEAD(void);
extern void test_refs_branches_ishead__can_properly_handle_missing_HEAD(void);
extern void test_refs_branches_ishead__can_tell_if_a_branch_is_not_pointed_at_by_HEAD(void);
extern void test_refs_branches_ishead__wont_be_fooled_by_a_non_branch(void);
extern void test_refs_branches_ishead__only_direct_references_are_considered(void);
extern void test_refs_branches_ishead__initialize(void);
extern void test_refs_branches_ishead__cleanup(void);
extern void test_refs_list__all(void);
extern void test_refs_list__do_not_retrieve_references_which_name_end_with_a_lock_extension(void);
extern void test_refs_list__initialize(void);
extern void test_refs_list__cleanup(void);
extern void test_object_blob_fromchunks__can_create_a_blob_from_a_in_memory_chunk_provider(void);
extern void test_object_blob_fromchunks__doesnot_overwrite_an_already_existing_object(void);
extern void test_object_blob_fromchunks__creating_a_blob_from_chunks_honors_the_attributes_directives(void);
extern void test_object_blob_fromchunks__initialize(void);
extern void test_object_blob_fromchunks__cleanup(void);
extern void test_object_cache__cache_everything(void);
extern void test_object_cache__cache_no_blobs(void);
extern void test_object_cache__threadmania(void);
extern void test_object_cache__fast_thread_rush(void);
extern void test_object_cache__initialize(void);
extern void test_object_cache__cleanup(void);
extern void test_filter_blob__all_crlf(void);
extern void test_filter_blob__ident(void);
extern void test_filter_blob__initialize(void);
extern void test_filter_blob__cleanup(void);
extern void test_refs_reflog_reflog__append_then_read(void);
extern void test_refs_reflog_reflog__append_to_then_read(void);
extern void test_refs_reflog_reflog__renaming_the_reference_moves_the_reflog(void);
extern void test_refs_reflog_reflog__reference_has_reflog(void);
extern void test_refs_reflog_reflog__reading_the_reflog_from_a_reference_with_no_log_returns_an_empty_one(void);
extern void test_refs_reflog_reflog__cannot_write_a_moved_reflog(void);
extern void test_refs_reflog_reflog__renaming_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_reflog_reflog__initialize(void);
extern void test_refs_reflog_reflog__cleanup(void);
extern void test_core_bitvec__0(void);
extern void test_submodule_lookup__simple_lookup(void);
extern void test_submodule_lookup__accessors(void);
extern void test_submodule_lookup__foreach(void);
extern void test_submodule_lookup__lookup_even_with_unborn_head(void);
extern void test_submodule_lookup__lookup_even_with_missing_index(void);
extern void test_submodule_lookup__initialize(void);
extern void test_diff_notify__notify_single_pathspec(void);
extern void test_diff_notify__notify_multiple_pathspec(void);
extern void test_diff_notify__notify_catchall_with_empty_pathspecs(void);
extern void test_diff_notify__notify_catchall(void);
extern void test_diff_notify__notify_cb_can_abort_diff(void);
extern void test_diff_notify__notify_cb_can_be_used_as_filtering_function(void);
extern void test_diff_notify__initialize(void);
extern void test_diff_notify__cleanup(void);
extern void test_config_configlevel__adding_the_same_level_twice_returns_EEXISTS(void);
extern void test_config_configlevel__can_replace_a_config_file_at_an_existing_level(void);
extern void test_config_configlevel__can_read_from_a_single_level_focused_file_after_parent_config_has_been_freed(void);
extern void test_config_configlevel__fetching_a_level_from_an_empty_compound_config_returns_ENOTFOUND(void);
extern void test_core_mkdir__basic(void);
extern void test_core_mkdir__with_base(void);
extern void test_core_mkdir__chmods(void);
extern void test_commit_write__from_memory(void);
extern void test_commit_write__root(void);
extern void test_commit_write__initialize(void);
extern void test_commit_write__cleanup(void);
extern void test_checkout_conflict__ignored(void);
extern void test_checkout_conflict__ours(void);
extern void test_checkout_conflict__theirs(void);
extern void test_checkout_conflict__diff3(void);
extern void test_checkout_conflict__automerge(void);
extern void test_checkout_conflict__directory_file(void);
extern void test_checkout_conflict__directory_file_with_custom_labels(void);
extern void test_checkout_conflict__link_file(void);
extern void test_checkout_conflict__links(void);
extern void test_checkout_conflict__add_add(void);
extern void test_checkout_conflict__mode_change(void);
extern void test_checkout_conflict__renames(void);
extern void test_checkout_conflict__rename_keep_ours(void);
extern void test_checkout_conflict__name_mangled_file_exists_in_workdir(void);
extern void test_checkout_conflict__update_only(void);
extern void test_checkout_conflict__path_filters(void);
extern void test_checkout_conflict__report_progress(void);
extern void test_checkout_conflict__initialize(void);
extern void test_checkout_conflict__cleanup(void);
extern void test_diff_tree__0(void);
extern void test_diff_tree__options(void);
extern void test_diff_tree__bare(void);
extern void test_diff_tree__merge(void);
extern void test_diff_tree__larger_hunks(void);
extern void test_diff_tree__checks_options_version(void);
extern void test_diff_tree__symlink_blob_mode_changed_to_regular_file(void);
extern void test_diff_tree__symlink_blob_mode_changed_to_regular_file_as_typechange(void);
extern void test_diff_tree__regular_blob_mode_changed_to_executable_file(void);
extern void test_diff_tree__issue_1397(void);
extern void test_diff_tree__diff_configs(void);
extern void test_diff_tree__initialize(void);
extern void test_diff_tree__cleanup(void);
extern void test_repo_message__none(void);
extern void test_repo_message__message(void);
extern void test_repo_message__initialize(void);
extern void test_repo_message__cleanup(void);
extern void test_pack_indexer__out_of_order(void);
extern void test_pack_indexer__fix_thin(void);
extern void test_object_raw_compare__succeed_on_copy_oid(void);
extern void test_object_raw_compare__succeed_on_oid_comparison_lesser(void);
extern void test_object_raw_compare__succeed_on_oid_comparison_equal(void);
extern void test_object_raw_compare__succeed_on_oid_comparison_greater(void);
extern void test_object_raw_compare__compare_fmt_oids(void);
extern void test_object_raw_compare__compare_allocfmt_oids(void);
extern void test_object_raw_compare__compare_pathfmt_oids(void);
extern void test_network_remote_rename__renaming_a_remote_moves_related_configuration_section(void);
extern void test_network_remote_rename__renaming_a_remote_updates_branch_related_configuration_entries(void);
extern void test_network_remote_rename__renaming_a_remote_updates_default_fetchrefspec(void);
extern void test_network_remote_rename__renaming_a_remote_without_a_fetchrefspec_doesnt_create_one(void);
extern void test_network_remote_rename__renaming_a_remote_notifies_of_non_default_fetchrefspec(void);
extern void test_network_remote_rename__new_name_can_contain_dots(void);
extern void test_network_remote_rename__new_name_must_conform_to_reference_naming_conventions(void);
extern void test_network_remote_rename__renamed_name_is_persisted(void);
extern void test_network_remote_rename__cannot_overwrite_an_existing_remote(void);
extern void test_network_remote_rename__renaming_a_remote_moves_the_underlying_reference(void);
extern void test_network_remote_rename__cannot_rename_an_inmemory_remote(void);
extern void test_network_remote_rename__initialize(void);
extern void test_network_remote_rename__cleanup(void);
extern void test_object_commit_commitstagedfile__generate_predictable_object_ids(void);
extern void test_object_commit_commitstagedfile__initialize(void);
extern void test_object_commit_commitstagedfile__cleanup(void);
extern void test_commit_parse__header(void);
extern void test_commit_parse__signature(void);
extern void test_commit_parse__entire_commit(void);
extern void test_commit_parse__details0(void);
extern void test_commit_parse__leading_lf(void);
extern void test_commit_parse__only_lf(void);
extern void test_commit_parse__initialize(void);
extern void test_commit_parse__cleanup(void);
extern void test_diff_blob__can_compare_text_blobs(void);
extern void test_diff_blob__can_compare_text_blobs_with_patch(void);
extern void test_diff_blob__can_compare_against_null_blobs(void);
extern void test_diff_blob__can_compare_against_null_blobs_with_patch(void);
extern void test_diff_blob__can_compare_identical_blobs(void);
extern void test_diff_blob__can_compare_identical_blobs_with_patch(void);
extern void test_diff_blob__can_compare_two_binary_blobs(void);
extern void test_diff_blob__can_compare_a_binary_blob_and_a_text_blob(void);
extern void test_diff_blob__comparing_two_text_blobs_honors_interhunkcontext(void);
extern void test_diff_blob__checks_options_version_too_low(void);
extern void test_diff_blob__checks_options_version_too_high(void);
extern void test_diff_blob__can_correctly_detect_a_binary_blob_as_binary(void);
extern void test_diff_blob__can_correctly_detect_a_textual_blob_as_non_binary(void);
extern void test_diff_blob__can_compare_blob_to_buffer(void);
extern void test_diff_blob__can_compare_blob_to_buffer_with_patch(void);
extern void test_diff_blob__binary_data_comparisons(void);
extern void test_diff_blob__using_path_and_attributes(void);
extern void test_diff_blob__initialize(void);
extern void test_diff_blob__cleanup(void);
extern void test_refs_read__loose_tag(void);
extern void test_refs_read__nonexisting_tag(void);
extern void test_refs_read__symbolic(void);
extern void test_refs_read__nested_symbolic(void);
extern void test_refs_read__head_then_master(void);
extern void test_refs_read__master_then_head(void);
extern void test_refs_read__packed(void);
extern void test_refs_read__loose_first(void);
extern void test_refs_read__chomped(void);
extern void test_refs_read__trailing(void);
extern void test_refs_read__unfound_return_ENOTFOUND(void);
extern void test_refs_read__can_determine_if_a_reference_is_a_local_branch(void);
extern void test_refs_read__can_determine_if_a_reference_is_a_tag(void);
extern void test_refs_read__invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_read__initialize(void);
extern void test_refs_read__cleanup(void);
extern void test_threads_refdb__iterator(void);
extern void test_threads_refdb__edit_while_iterate(void);
extern void test_threads_refdb__initialize(void);
extern void test_threads_refdb__cleanup(void);
extern void test_config_validkeyname__accessing_requires_a_valid_name(void);
extern void test_config_validkeyname__renaming_a_section_requires_a_valid_name(void);
extern void test_config_validkeyname__initialize(void);
extern void test_config_validkeyname__cleanup(void);
extern void test_refs_branches_delete__can_not_delete_a_branch_pointed_at_by_HEAD(void);
extern void test_refs_branches_delete__can_delete_a_branch_even_if_HEAD_is_missing(void);
extern void test_refs_branches_delete__can_delete_a_branch_when_HEAD_is_unborn(void);
extern void test_refs_branches_delete__can_delete_a_branch_pointed_at_by_detached_HEAD(void);
extern void test_refs_branches_delete__can_delete_a_local_branch(void);
extern void test_refs_branches_delete__can_delete_a_remote_branch(void);
extern void test_refs_branches_delete__deleting_a_branch_removes_related_configuration_data(void);
extern void test_refs_branches_delete__initialize(void);
extern void test_refs_branches_delete__cleanup(void);
extern void test_date_date__overflow(void);
extern void test_refs_pack__empty(void);
extern void test_refs_pack__loose(void);
extern void test_refs_pack__symbolic(void);
extern void test_refs_pack__initialize(void);
extern void test_refs_pack__cleanup(void);
extern void test_refs_overwrite__symbolic(void);
extern void test_refs_overwrite__object_id(void);
extern void test_refs_overwrite__object_id_with_symbolic(void);
extern void test_refs_overwrite__symbolic_with_object_id(void);
extern void test_refs_overwrite__initialize(void);
extern void test_refs_overwrite__cleanup(void);
extern void test_merge_workdir_simple__automerge(void);
extern void test_merge_workdir_simple__automerge_crlf(void);
extern void test_merge_workdir_simple__diff3(void);
extern void test_merge_workdir_simple__checkout_ours(void);
extern void test_merge_workdir_simple__favor_ours(void);
extern void test_merge_workdir_simple__favor_theirs(void);
extern void test_merge_workdir_simple__directory_file(void);
extern void test_merge_workdir_simple__unrelated(void);
extern void test_merge_workdir_simple__unrelated_with_conflicts(void);
extern void test_merge_workdir_simple__initialize(void);
extern void test_merge_workdir_simple__cleanup(void);
extern void test_revwalk_signatureparsing__do_not_choke_when_name_contains_angle_brackets(void);
extern void test_revwalk_signatureparsing__initialize(void);
extern void test_revwalk_signatureparsing__cleanup(void);
extern void test_core_opts__readwrite(void);
extern void test_object_tag_write__basic(void);
extern void test_object_tag_write__overwrite(void);
extern void test_object_tag_write__replace(void);
extern void test_object_tag_write__lightweight(void);
extern void test_object_tag_write__lightweight_over_existing(void);
extern void test_object_tag_write__delete(void);
extern void test_object_tag_write__creating_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_object_tag_write__deleting_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_object_tag_write__creating_an_annotation_stores_the_new_object_in_the_odb(void);
extern void test_object_tag_write__creating_an_annotation_does_not_create_a_reference(void);
extern void test_object_tag_write__initialize(void);
extern void test_object_tag_write__cleanup(void);
extern void test_config_backend__checks_version(void);
extern void test_refs_branches_upstreamname__can_retrieve_the_remote_tracking_reference_name_of_a_local_branch(void);
extern void test_refs_branches_upstreamname__can_retrieve_the_local_upstream_reference_name_of_a_local_branch(void);
extern void test_refs_branches_upstreamname__can_return_the_size_of_thelocal_upstream_reference_name_of_a_local_branch(void);
extern void test_refs_branches_upstreamname__initialize(void);
extern void test_refs_branches_upstreamname__cleanup(void);
extern void test_network_fetchlocal__complete(void);
extern void test_network_fetchlocal__partial(void);
extern void test_refs_branches_name__can_get_local_branch_name(void);
extern void test_refs_branches_name__can_get_remote_branch_name(void);
extern void test_refs_branches_name__error_when_ref_is_no_branch(void);
extern void test_refs_branches_name__initialize(void);
extern void test_refs_branches_name__cleanup(void);
extern void test_odb_streamwrite__can_accept_chunks(void);
extern void test_odb_streamwrite__can_detect_missing_bytes(void);
extern void test_odb_streamwrite__can_detect_additional_bytes(void);
extern void test_odb_streamwrite__initialize(void);
extern void test_odb_streamwrite__cleanup(void);
extern void test_odb_foreach__foreach(void);
extern void test_odb_foreach__one_pack(void);
extern void test_odb_foreach__interrupt_foreach(void);
extern void test_odb_foreach__cleanup(void);
extern void test_checkout_head__unborn_head_returns_GIT_EUNBORNBRANCH(void);
extern void test_checkout_head__with_index_only_tree(void);
extern void test_checkout_head__initialize(void);
extern void test_checkout_head__cleanup(void);
extern void test_reset_default__resetting_filepaths_against_a_null_target_removes_them_from_the_index(void);
extern void test_reset_default__resetting_filepaths_replaces_their_corresponding_index_entries(void);
extern void test_reset_default__resetting_filepaths_clears_previous_conflicts(void);
extern void test_reset_default__resetting_unknown_filepaths_does_not_fail(void);
extern void test_reset_default__initialize(void);
extern void test_reset_default__cleanup(void);
extern void test_refs_branches_upstream__can_retrieve_the_remote_tracking_reference_of_a_local_branch(void);
extern void test_refs_branches_upstream__can_retrieve_the_local_upstream_reference_of_a_local_branch(void);
extern void test_refs_branches_upstream__cannot_retrieve_a_remote_upstream_reference_from_a_non_branch(void);
extern void test_refs_branches_upstream__trying_to_retrieve_a_remote_tracking_reference_from_a_plain_local_branch_returns_GIT_ENOTFOUND(void);
extern void test_refs_branches_upstream__trying_to_retrieve_a_remote_tracking_reference_from_a_branch_with_no_fetchspec_returns_GIT_ENOTFOUND(void);
extern void test_refs_branches_upstream__retrieve_a_remote_tracking_reference_from_a_branch_with_no_remote_returns_GIT_ENOTFOUND(void);
extern void test_refs_branches_upstream__set_unset_upstream(void);
extern void test_refs_branches_upstream__initialize(void);
extern void test_refs_branches_upstream__cleanup(void);
extern void test_odb_mixed__dup_oid(void);
extern void test_odb_mixed__dup_oid_prefix_0(void);
extern void test_odb_mixed__initialize(void);
extern void test_odb_mixed__cleanup(void);
extern void test_merge_workdir_fastforward__fastforward(void);
extern void test_merge_workdir_fastforward__fastforward_only(void);
extern void test_merge_workdir_fastforward__no_fastforward(void);
extern void test_merge_workdir_fastforward__uptodate(void);
extern void test_merge_workdir_fastforward__uptodate_merging_prev_commit(void);
extern void test_merge_workdir_fastforward__initialize(void);
extern void test_merge_workdir_fastforward__cleanup(void);
extern void test_diff_iterator__tree_0(void);
extern void test_diff_iterator__tree_1(void);
extern void test_diff_iterator__tree_2(void);
extern void test_diff_iterator__tree_3(void);
extern void test_diff_iterator__tree_4(void);
extern void test_diff_iterator__tree_4_ranged(void);
extern void test_diff_iterator__tree_ranged_0(void);
extern void test_diff_iterator__tree_ranged_1(void);
extern void test_diff_iterator__tree_range_empty_0(void);
extern void test_diff_iterator__tree_range_empty_1(void);
extern void test_diff_iterator__tree_range_empty_2(void);
extern void test_diff_iterator__tree_special_functions(void);
extern void test_diff_iterator__index_0(void);
extern void test_diff_iterator__index_range(void);
extern void test_diff_iterator__index_range_empty_0(void);
extern void test_diff_iterator__index_range_empty_1(void);
extern void test_diff_iterator__index_range_empty_2(void);
extern void test_diff_iterator__index_1(void);
extern void test_diff_iterator__workdir_0(void);
extern void test_diff_iterator__workdir_1(void);
extern void test_diff_iterator__workdir_1_ranged_0(void);
extern void test_diff_iterator__workdir_1_ranged_1(void);
extern void test_diff_iterator__workdir_1_ranged_3(void);
extern void test_diff_iterator__workdir_1_ranged_4(void);
extern void test_diff_iterator__workdir_1_ranged_5(void);
extern void test_diff_iterator__workdir_1_ranged_empty_0(void);
extern void test_diff_iterator__workdir_1_ranged_empty_1(void);
extern void test_diff_iterator__workdir_1_ranged_empty_2(void);
extern void test_diff_iterator__workdir_builtin_ignores(void);
extern void test_diff_iterator__workdir_handles_icase_range(void);
extern void test_diff_iterator__tree_handles_icase_range(void);
extern void test_diff_iterator__index_handles_icase_range(void);
extern void test_diff_iterator__initialize(void);
extern void test_diff_iterator__cleanup(void);
extern void test_merge_trees_trivial__2alt(void);
extern void test_merge_trees_trivial__3alt(void);
extern void test_merge_trees_trivial__4(void);
extern void test_merge_trees_trivial__5alt_1(void);
extern void test_merge_trees_trivial__5alt_2(void);
extern void test_merge_trees_trivial__6(void);
extern void test_merge_trees_trivial__6_automerge(void);
extern void test_merge_trees_trivial__8(void);
extern void test_merge_trees_trivial__8_automerge(void);
extern void test_merge_trees_trivial__7(void);
extern void test_merge_trees_trivial__7_automerge(void);
extern void test_merge_trees_trivial__10(void);
extern void test_merge_trees_trivial__10_automerge(void);
extern void test_merge_trees_trivial__9(void);
extern void test_merge_trees_trivial__9_automerge(void);
extern void test_merge_trees_trivial__13(void);
extern void test_merge_trees_trivial__14(void);
extern void test_merge_trees_trivial__11(void);
extern void test_merge_trees_trivial__initialize(void);
extern void test_merge_trees_trivial__cleanup(void);
extern void test_core_dirent__dont_traverse_dot(void);
extern void test_core_dirent__traverse_subfolder(void);
extern void test_core_dirent__traverse_slash_terminated_folder(void);
extern void test_core_dirent__dont_traverse_empty_folders(void);
extern void test_core_dirent__traverse_weird_filenames(void);
extern void test_core_dirent__length_limits(void);
extern void test_core_dirent__empty_dir(void);
extern void test_index_addall__repo_lifecycle(void);
extern void test_index_addall__initialize(void);
extern void test_index_addall__cleanup(void);
extern void test_refs_shorthand__0(void);
extern void test_index_read_tree__read_write_involution(void);
extern void test_clone_nonetwork__bad_urls(void);
extern void test_clone_nonetwork__do_not_clean_existing_directory(void);
extern void test_clone_nonetwork__local(void);
extern void test_clone_nonetwork__local_absolute_path(void);
extern void test_clone_nonetwork__local_bare(void);
extern void test_clone_nonetwork__fail_when_the_target_is_a_file(void);
extern void test_clone_nonetwork__fail_with_already_existing_but_non_empty_directory(void);
extern void test_clone_nonetwork__custom_origin_name(void);
extern void test_clone_nonetwork__defaults(void);
extern void test_clone_nonetwork__cope_with_already_existing_directory(void);
extern void test_clone_nonetwork__can_prevent_the_checkout_of_a_standard_repo(void);
extern void test_clone_nonetwork__can_checkout_given_branch(void);
extern void test_clone_nonetwork__can_detached_head(void);
extern void test_clone_nonetwork__initialize(void);
extern void test_clone_nonetwork__cleanup(void);
extern void test_index_tests__empty_index(void);
extern void test_index_tests__default_test_index(void);
extern void test_index_tests__gitgit_index(void);
extern void test_index_tests__find_in_existing(void);
extern void test_index_tests__find_in_empty(void);
extern void test_index_tests__write(void);
extern void test_index_tests__sort0(void);
extern void test_index_tests__sort1(void);
extern void test_index_tests__add(void);
extern void test_index_tests__add_issue_1397(void);
extern void test_index_tests__add_bypath_to_a_bare_repository_returns_EBAREPO(void);
extern void test_index_tests__write_invalid_filename(void);
extern void test_index_tests__remove_entry(void);
extern void test_index_tests__remove_directory(void);
extern void test_index_tests__preserves_case(void);
extern void test_index_tests__elocked(void);
extern void test_index_tests__reload_from_disk(void);
extern void test_index_tests__corrupted_extension(void);
extern void test_index_tests__initialize(void);
extern void test_commit_commit__create_unexisting_update_ref(void);
extern void test_commit_commit__initialize(void);
extern void test_commit_commit__cleanup(void);
extern void test_blame_getters__byindex(void);
extern void test_blame_getters__byline(void);
extern void test_blame_getters__initialize(void);
extern void test_blame_getters__cleanup(void);
extern void test_repo_config__open_missing_global(void);
extern void test_repo_config__open_missing_global_with_separators(void);
extern void test_repo_config__read_no_configs(void);
extern void test_repo_config__initialize(void);
extern void test_repo_config__cleanup(void);
extern void test_odb_packed_one__mass_read(void);
extern void test_odb_packed_one__read_header_0(void);
extern void test_odb_packed_one__initialize(void);
extern void test_odb_packed_one__cleanup(void);
extern void test_object_tag_read__parse(void);
extern void test_object_tag_read__parse_without_tagger(void);
extern void test_object_tag_read__parse_without_message(void);
extern void test_object_tag_read__without_tagger_nor_message(void);
extern void test_object_tag_read__initialize(void);
extern void test_object_tag_read__cleanup(void);
extern void test_status_submodules__api(void);
extern void test_status_submodules__0(void);
extern void test_status_submodules__1(void);
extern void test_status_submodules__single_file(void);
extern void test_status_submodules__moved_head(void);
extern void test_status_submodules__dirty_workdir_only(void);
extern void test_status_submodules__initialize(void);
extern void test_status_submodules__cleanup(void);
extern void test_core_oid__streq(void);
extern void test_core_oid__strcmp(void);
extern void test_core_oid__ncmp(void);
extern void test_core_oid__initialize(void);
extern void test_index_inmemory__can_create_an_inmemory_index(void);
extern void test_index_inmemory__cannot_add_bypath_to_an_inmemory_index(void);
extern void test_refs_branches_move__can_move_a_local_branch(void);
extern void test_refs_branches_move__can_move_a_local_branch_to_a_different_namespace(void);
extern void test_refs_branches_move__can_move_a_local_branch_to_a_partially_colliding_namespace(void);
extern void test_refs_branches_move__can_not_move_a_branch_if_its_destination_name_collide_with_an_existing_one(void);
extern void test_refs_branches_move__moving_a_branch_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_branches_move__can_not_move_a_non_branch(void);
extern void test_refs_branches_move__can_force_move_over_an_existing_branch(void);
extern void test_refs_branches_move__moving_a_branch_moves_related_configuration_data(void);
extern void test_refs_branches_move__moving_the_branch_pointed_at_by_HEAD_updates_HEAD(void);
extern void test_refs_branches_move__initialize(void);
extern void test_refs_branches_move__cleanup(void);
extern void test_notes_notesref__config_corenotesref(void);
extern void test_notes_notesref__initialize(void);
extern void test_notes_notesref__cleanup(void);
extern void test_core_errors__public_api(void);
extern void test_core_errors__new_school(void);
extern void test_network_remote_isvalidname__can_detect_invalid_formats(void);
extern void test_network_remote_isvalidname__wont_hopefully_choke_on_valid_formats(void);
extern void test_repo_state__none_with_HEAD_attached(void);
extern void test_repo_state__none_with_HEAD_detached(void);
extern void test_repo_state__merge(void);
extern void test_repo_state__revert(void);
extern void test_repo_state__cherry_pick(void);
extern void test_repo_state__bisect(void);
extern void test_repo_state__rebase_interactive(void);
extern void test_repo_state__rebase_merge(void);
extern void test_repo_state__rebase(void);
extern void test_repo_state__apply_mailbox(void);
extern void test_repo_state__apply_mailbox_or_rebase(void);
extern void test_repo_state__initialize(void);
extern void test_repo_state__cleanup(void);
extern void test_blame_harder__m(void);
extern void test_blame_harder__c(void);
extern void test_blame_harder__cc(void);
extern void test_blame_harder__ccc(void);
extern void test_blame_harder__initialize(void);
extern void test_blame_harder__cleanup(void);
extern void test_stash_save__does_not_keep_index_by_default(void);
extern void test_stash_save__can_keep_index(void);
extern void test_stash_save__can_include_untracked_files(void);
extern void test_stash_save__can_include_untracked_and_ignored_files(void);
extern void test_stash_save__can_accept_a_message(void);
extern void test_stash_save__cannot_stash_against_an_unborn_branch(void);
extern void test_stash_save__cannot_stash_against_a_bare_repository(void);
extern void test_stash_save__can_stash_against_a_detached_head(void);
extern void test_stash_save__stashing_updates_the_reflog(void);
extern void test_stash_save__cannot_stash_when_there_are_no_local_change(void);
extern void test_stash_save__can_stage_normal_then_stage_untracked(void);
extern void test_stash_save__including_untracked_without_any_untracked_file_creates_an_empty_tree(void);
extern void test_stash_save__initialize(void);
extern void test_stash_save__cleanup(void);
extern void test_repo_discover__0(void);
extern void test_refs_update__updating_the_target_of_a_symref_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_update__initialize(void);
extern void test_refs_update__cleanup(void);
extern void test_status_ignore__0(void);
extern void test_status_ignore__1(void);
extern void test_status_ignore__empty_repo_with_gitignore_rewrite(void);
extern void test_status_ignore__ignore_pattern_contains_space(void);
extern void test_status_ignore__ignore_pattern_ignorecase(void);
extern void test_status_ignore__subdirectories(void);
extern void test_status_ignore__subdirectories_recursion(void);
extern void test_status_ignore__adding_internal_ignores(void);
extern void test_status_ignore__add_internal_as_first_thing(void);
extern void test_status_ignore__internal_ignores_inside_deep_paths(void);
extern void test_status_ignore__automatically_ignore_bad_files(void);
extern void test_status_ignore__filenames_with_special_prefixes_do_not_interfere_with_status_retrieval(void);
extern void test_status_ignore__issue_1766_negated_ignores(void);
extern void test_status_ignore__initialize(void);
extern void test_status_ignore__cleanup(void);
extern void test_attr_file__simple_read(void);
extern void test_attr_file__match_variants(void);
extern void test_attr_file__assign_variants(void);
extern void test_attr_file__check_attr_examples(void);
extern void test_core_buffer__0(void);
extern void test_core_buffer__1(void);
extern void test_core_buffer__2(void);
extern void test_core_buffer__3(void);
extern void test_core_buffer__4(void);
extern void test_core_buffer__5(void);
extern void test_core_buffer__6(void);
extern void test_core_buffer__7(void);
extern void test_core_buffer__8(void);
extern void test_core_buffer__9(void);
extern void test_core_buffer__10(void);
extern void test_core_buffer__11(void);
extern void test_core_buffer__rfind_variants(void);
extern void test_core_buffer__puts_escaped(void);
extern void test_core_buffer__unescape(void);
extern void test_core_buffer__base64(void);
extern void test_core_buffer__classify_with_utf8(void);
extern void test_core_buffer__similarity_metric(void);
extern void test_core_buffer__similarity_metric_whitespace(void);
extern void test_core_buffer__lf_and_crlf_conversions(void);
extern void test_checkout_tree__cannot_checkout_a_non_treeish(void);
extern void test_checkout_tree__can_checkout_a_subdirectory_from_a_commit(void);
extern void test_checkout_tree__can_checkout_and_remove_directory(void);
extern void test_checkout_tree__can_checkout_a_subdirectory_from_a_subtree(void);
extern void test_checkout_tree__calls_progress_callback(void);
extern void test_checkout_tree__doesnt_write_unrequested_files_to_worktree(void);
extern void test_checkout_tree__can_switch_branches(void);
extern void test_checkout_tree__can_remove_untracked(void);
extern void test_checkout_tree__can_remove_ignored(void);
extern void test_checkout_tree__can_update_only(void);
extern void test_checkout_tree__can_checkout_with_pattern(void);
extern void test_checkout_tree__can_disable_pattern_match(void);
extern void test_checkout_tree__checking_out_a_conflicting_type_change_returns_EMERGECONFLICT(void);
extern void test_checkout_tree__checking_out_a_conflicting_type_change_returns_EMERGECONFLICT_2(void);
extern void test_checkout_tree__checking_out_a_conflicting_content_change_returns_EMERGECONFLICT(void);
extern void test_checkout_tree__donot_update_deleted_file_by_default(void);
extern void test_checkout_tree__can_checkout_with_last_workdir_item_missing(void);
extern void test_checkout_tree__issue_1397(void);
extern void test_checkout_tree__can_write_to_empty_dirs(void);
extern void test_checkout_tree__fails_when_dir_in_use(void);
extern void test_checkout_tree__can_continue_when_dir_in_use(void);
extern void test_checkout_tree__target_directory_from_bare(void);
extern void test_checkout_tree__extremely_long_file_name(void);
extern void test_checkout_tree__fails_when_conflicts_exist_in_index(void);
extern void test_checkout_tree__initialize(void);
extern void test_checkout_tree__cleanup(void);
extern void test_index_conflicts__add(void);
extern void test_index_conflicts__add_fixes_incorrect_stage(void);
extern void test_index_conflicts__get(void);
extern void test_index_conflicts__iterate(void);
extern void test_index_conflicts__remove(void);
extern void test_index_conflicts__moved_to_reuc_on_add(void);
extern void test_index_conflicts__moved_to_reuc_on_remove(void);
extern void test_index_conflicts__remove_all_conflicts(void);
extern void test_index_conflicts__partial(void);
extern void test_index_conflicts__initialize(void);
extern void test_index_conflicts__cleanup(void);
extern void test_network_refspecs__parsing(void);
extern void test_checkout_index__cannot_checkout_a_bare_repository(void);
extern void test_checkout_index__can_create_missing_files(void);
extern void test_checkout_index__can_remove_untracked_files(void);
extern void test_checkout_index__honor_the_specified_pathspecs(void);
extern void test_checkout_index__honor_the_gitattributes_directives(void);
extern void test_checkout_index__honor_coreautocrlf_setting_set_to_true(void);
extern void test_checkout_index__honor_coresymlinks_setting_set_to_true(void);
extern void test_checkout_index__honor_coresymlinks_setting_set_to_false(void);
extern void test_checkout_index__donot_overwrite_modified_file_by_default(void);
extern void test_checkout_index__can_overwrite_modified_file(void);
extern void test_checkout_index__options_disable_filters(void);
extern void test_checkout_index__options_dir_modes(void);
extern void test_checkout_index__options_override_file_modes(void);
extern void test_checkout_index__options_open_flags(void);
extern void test_checkout_index__can_notify_of_skipped_files(void);
extern void test_checkout_index__wont_notify_of_expected_line_ending_changes(void);
extern void test_checkout_index__calls_progress_callback(void);
extern void test_checkout_index__can_overcome_name_clashes(void);
extern void test_checkout_index__validates_struct_version(void);
extern void test_checkout_index__can_update_prefixed_files(void);
extern void test_checkout_index__can_checkout_a_newly_initialized_repository(void);
extern void test_checkout_index__issue_1397(void);
extern void test_checkout_index__target_directory(void);
extern void test_checkout_index__target_directory_from_bare(void);
extern void test_checkout_index__can_get_repo_from_index(void);
extern void test_checkout_index__initialize(void);
extern void test_checkout_index__cleanup(void);
extern void test_network_remote_local__connected(void);
extern void test_network_remote_local__retrieve_advertised_references(void);
extern void test_network_remote_local__retrieve_advertised_references_after_disconnect(void);
extern void test_network_remote_local__retrieve_advertised_references_from_spaced_repository(void);
extern void test_network_remote_local__nested_tags_are_completely_peeled(void);
extern void test_network_remote_local__shorthand_fetch_refspec0(void);
extern void test_network_remote_local__shorthand_fetch_refspec1(void);
extern void test_network_remote_local__tagopt(void);
extern void test_network_remote_local__push_to_bare_remote(void);
extern void test_network_remote_local__push_to_non_bare_remote(void);
extern void test_network_remote_local__initialize(void);
extern void test_network_remote_local__cleanup(void);
extern void test_index_stage__add_always_adds_stage_0(void);
extern void test_index_stage__find_gets_first_stage(void);
extern void test_index_stage__initialize(void);
extern void test_index_stage__cleanup(void);
extern void test_blame_simple__trivial_testrepo(void);
extern void test_blame_simple__trivial_blamerepo(void);
extern void test_blame_simple__trivial_libgit2(void);
extern void test_blame_simple__can_restrict_lines_min(void);
extern void test_blame_simple__can_restrict_lines_max(void);
extern void test_blame_simple__can_restrict_lines_both(void);
extern void test_blame_simple__can_restrict_to_newish_commits(void);
extern void test_blame_simple__initialize(void);
extern void test_blame_simple__cleanup(void);
extern void test_config_stress__dont_break_on_invalid_input(void);
extern void test_config_stress__comments(void);
extern void test_config_stress__escape_subsection_names(void);
extern void test_config_stress__trailing_backslash(void);
extern void test_config_stress__initialize(void);
extern void test_config_stress__cleanup(void);
extern void test_core_copy__file(void);
extern void test_core_copy__file_in_dir(void);
extern void test_core_copy__tree(void);
extern void test_diff_submodules__unmodified_submodule(void);
extern void test_diff_submodules__dirty_submodule(void);
extern void test_diff_submodules__dirty_submodule_2(void);
extern void test_diff_submodules__submod2_index_to_wd(void);
extern void test_diff_submodules__submod2_head_to_index(void);
extern void test_diff_submodules__invalid_cache(void);
extern void test_diff_submodules__diff_ignore_options(void);
extern void test_diff_submodules__initialize(void);
extern void test_diff_submodules__cleanup(void);
extern void test_object_raw_type2string__convert_type_to_string(void);
extern void test_object_raw_type2string__convert_string_to_type(void);
extern void test_object_raw_type2string__check_type_is_loose(void);
extern void test_object_tree_write__from_memory(void);
extern void test_object_tree_write__subtree(void);
extern void test_object_tree_write__sorted_subtrees(void);
extern void test_object_tree_write__removing_and_re_adding_in_treebuilder(void);
extern void test_object_tree_write__initialize(void);
extern void test_object_tree_write__cleanup(void);
extern void test_config_write__replace_value(void);
extern void test_config_write__delete_value(void);
extern void test_config_write__delete_value_at_specific_level(void);
extern void test_config_write__write_subsection(void);
extern void test_config_write__delete_inexistent(void);
extern void test_config_write__value_containing_quotes(void);
extern void test_config_write__escape_value(void);
extern void test_config_write__add_value_at_specific_level(void);
extern void test_config_write__add_value_at_file_with_no_clrf_at_the_end(void);
extern void test_config_write__add_value_which_needs_quotes(void);
extern void test_config_write__can_set_a_value_to_NULL(void);
extern void test_config_write__can_set_an_empty_value(void);
extern void test_config_write__updating_a_locked_config_file_returns_ELOCKED(void);
extern void test_config_write__initialize(void);
extern void test_config_write__cleanup(void);
extern void test_status_renames__head2index_one(void);
extern void test_status_renames__head2index_two(void);
extern void test_status_renames__head2index_no_rename_from_rewrite(void);
extern void test_status_renames__head2index_rename_from_rewrite(void);
extern void test_status_renames__index2workdir_one(void);
extern void test_status_renames__index2workdir_two(void);
extern void test_status_renames__index2workdir_rename_from_rewrite(void);
extern void test_status_renames__both_one(void);
extern void test_status_renames__both_two(void);
extern void test_status_renames__both_rename_from_rewrite(void);
extern void test_status_renames__rewrites_only_for_renames(void);
extern void test_status_renames__both_casechange_one(void);
extern void test_status_renames__both_casechange_two(void);
extern void test_status_renames__initialize(void);
extern void test_status_renames__cleanup(void);
extern void test_merge_trees_automerge__automerge(void);
extern void test_merge_trees_automerge__favor_ours(void);
extern void test_merge_trees_automerge__favor_theirs(void);
extern void test_merge_trees_automerge__unrelated(void);
extern void test_merge_trees_automerge__initialize(void);
extern void test_merge_trees_automerge__cleanup(void);
extern void test_object_tree_attributes__ensure_correctness_of_attributes_on_insertion(void);
extern void test_object_tree_attributes__group_writable_tree_entries_created_with_an_antique_git_version_can_still_be_accessed(void);
extern void test_object_tree_attributes__treebuilder_reject_invalid_filemode(void);
extern void test_object_tree_attributes__normalize_attributes_when_creating_a_tree_from_an_existing_one(void);
extern void test_object_tree_attributes__normalize_600(void);
extern void test_checkout_crlf__detect_crlf_autocrlf_false(void);
extern void test_checkout_crlf__autocrlf_false_index_size_is_unfiltered_size(void);
extern void test_checkout_crlf__detect_crlf_autocrlf_true(void);
extern void test_checkout_crlf__more_lf_autocrlf_true(void);
extern void test_checkout_crlf__more_crlf_autocrlf_true(void);
extern void test_checkout_crlf__all_crlf_autocrlf_true(void);
extern void test_checkout_crlf__autocrlf_true_index_size_is_filtered_size(void);
extern void test_checkout_crlf__with_ident(void);
extern void test_checkout_crlf__initialize(void);
extern void test_checkout_crlf__cleanup(void);
extern void test_config_multivar__foreach(void);
extern void test_config_multivar__get(void);
extern void test_config_multivar__add(void);
extern void test_config_multivar__add_new(void);
extern void test_config_multivar__replace(void);
extern void test_config_multivar__replace_multiple(void);
extern void test_config_multivar__delete(void);
extern void test_config_multivar__delete_multiple(void);
extern void test_config_multivar__delete_notfound(void);
extern void test_config_multivar__initialize(void);
extern void test_config_multivar__cleanup(void);
extern void test_network_urlparse__trivial(void);
extern void test_network_urlparse__encoded_password(void);
extern void test_network_urlparse__user(void);
extern void test_network_urlparse__user_pass(void);
extern void test_network_urlparse__port(void);
extern void test_network_urlparse__user_port(void);
extern void test_network_urlparse__user_pass_port(void);
extern void test_network_urlparse__connection_data_http(void);
extern void test_network_urlparse__connection_data_ssl(void);
extern void test_network_urlparse__encoded_username_password(void);
extern void test_network_urlparse__connection_data_cross_host_redirect(void);
extern void test_network_urlparse__connection_data_http_downgrade(void);
extern void test_network_urlparse__connection_data_relative_redirect(void);
extern void test_network_urlparse__connection_data_relative_redirect_ssl(void);
extern void test_network_urlparse__connection_data_cleanup(void);
extern void test_network_urlparse__initialize(void);
extern void test_network_urlparse__cleanup(void);
extern void test_merge_workdir_trivial__2alt(void);
extern void test_merge_workdir_trivial__3alt(void);
extern void test_merge_workdir_trivial__4(void);
extern void test_merge_workdir_trivial__5alt_1(void);
extern void test_merge_workdir_trivial__5alt_2(void);
extern void test_merge_workdir_trivial__6(void);
extern void test_merge_workdir_trivial__6_automerge(void);
extern void test_merge_workdir_trivial__8(void);
extern void test_merge_workdir_trivial__8_automerge(void);
extern void test_merge_workdir_trivial__7(void);
extern void test_merge_workdir_trivial__7_automerge(void);
extern void test_merge_workdir_trivial__10(void);
extern void test_merge_workdir_trivial__10_automerge(void);
extern void test_merge_workdir_trivial__9(void);
extern void test_merge_workdir_trivial__9_automerge(void);
extern void test_merge_workdir_trivial__13(void);
extern void test_merge_workdir_trivial__14(void);
extern void test_merge_workdir_trivial__11(void);
extern void test_merge_workdir_trivial__initialize(void);
extern void test_merge_workdir_trivial__cleanup(void);
extern void test_filter_crlf__to_worktree(void);
extern void test_filter_crlf__to_odb(void);
extern void test_filter_crlf__initialize(void);
extern void test_filter_crlf__cleanup(void);
extern void test_network_remote_remotes__parsing(void);
extern void test_network_remote_remotes__pushurl(void);
extern void test_network_remote_remotes__error_when_no_push_available(void);
extern void test_network_remote_remotes__parsing_ssh_remote(void);
extern void test_network_remote_remotes__parsing_local_path_fails_if_path_not_found(void);
extern void test_network_remote_remotes__supported_transport_methods_are_supported(void);
extern void test_network_remote_remotes__unsupported_transport_methods_are_unsupported(void);
extern void test_network_remote_remotes__refspec_parsing(void);
extern void test_network_remote_remotes__add_fetchspec(void);
extern void test_network_remote_remotes__add_pushspec(void);
extern void test_network_remote_remotes__save(void);
extern void test_network_remote_remotes__fnmatch(void);
extern void test_network_remote_remotes__transform(void);
extern void test_network_remote_remotes__transform_destination_to_source(void);
extern void test_network_remote_remotes__transform_r(void);
extern void test_network_remote_remotes__missing_refspecs(void);
extern void test_network_remote_remotes__list(void);
extern void test_network_remote_remotes__loading_a_missing_remote_returns_ENOTFOUND(void);
extern void test_network_remote_remotes__loading_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_network_remote_remotes__add(void);
extern void test_network_remote_remotes__cannot_add_a_nameless_remote(void);
extern void test_network_remote_remotes__cannot_save_an_inmemory_remote(void);
extern void test_network_remote_remotes__cannot_add_a_remote_with_an_invalid_name(void);
extern void test_network_remote_remotes__tagopt(void);
extern void test_network_remote_remotes__can_load_with_an_empty_url(void);
extern void test_network_remote_remotes__can_load_with_only_an_empty_pushurl(void);
extern void test_network_remote_remotes__returns_ENOTFOUND_when_neither_url_nor_pushurl(void);
extern void test_network_remote_remotes__check_structure_version(void);
extern void test_network_remote_remotes__cannot_create_a_remote_which_name_conflicts_with_an_existing_remote(void);
extern void test_network_remote_remotes__cannot_create_a_remote_which_name_is_invalid(void);
extern void test_network_remote_remotes__query_refspecs(void);
extern void test_network_remote_remotes__initialize(void);
extern void test_network_remote_remotes__cleanup(void);
extern void test_attr_flags__bare(void);
extern void test_attr_flags__index_vs_workdir(void);
extern void test_attr_flags__subdir(void);
extern void test_attr_flags__cleanup(void);
extern void test_repo_iterator__index(void);
extern void test_repo_iterator__index_icase(void);
extern void test_repo_iterator__tree(void);
extern void test_repo_iterator__tree_icase(void);
extern void test_repo_iterator__tree_more(void);
extern void test_repo_iterator__tree_case_conflicts_0(void);
extern void test_repo_iterator__tree_case_conflicts_1(void);
extern void test_repo_iterator__tree_case_conflicts_2(void);
extern void test_repo_iterator__workdir(void);
extern void test_repo_iterator__workdir_icase(void);
extern void test_repo_iterator__workdir_depth(void);
extern void test_repo_iterator__fs(void);
extern void test_repo_iterator__fs2(void);
extern void test_repo_iterator__fs_preserves_error(void);
extern void test_repo_iterator__initialize(void);
extern void test_repo_iterator__cleanup(void);
extern void test_refs_crashes__double_free(void);
extern void test_refs_isvalidname__can_detect_invalid_formats(void);
extern void test_refs_isvalidname__wont_hopefully_choke_on_valid_formats(void);
extern void test_merge_trees_renames__index(void);
extern void test_merge_trees_renames__no_rename_index(void);
extern void test_merge_trees_renames__initialize(void);
extern void test_merge_trees_renames__cleanup(void);
extern void test_network_remote_createthenload__parsing(void);
extern void test_network_remote_createthenload__initialize(void);
extern void test_network_remote_createthenload__cleanup(void);
extern void test_odb_packed__mass_read(void);
extern void test_odb_packed__read_header_0(void);
extern void test_odb_packed__read_header_1(void);
extern void test_odb_packed__initialize(void);
extern void test_odb_packed__cleanup(void);
extern void test_attr_repo__get_one(void);
extern void test_attr_repo__get_many(void);
extern void test_attr_repo__get_many_in_place(void);
extern void test_attr_repo__foreach(void);
extern void test_attr_repo__manpage_example(void);
extern void test_attr_repo__macros(void);
extern void test_attr_repo__bad_macros(void);
extern void test_attr_repo__staging_properly_normalizes_line_endings_according_to_gitattributes_directives(void);
extern void test_attr_repo__initialize(void);
extern void test_attr_repo__cleanup(void);
extern void test_refs_reflog_drop__dropping_a_non_exisiting_entry_from_the_log_returns_ENOTFOUND(void);
extern void test_refs_reflog_drop__can_drop_an_entry(void);
extern void test_refs_reflog_drop__can_drop_an_entry_and_rewrite_the_log_history(void);
extern void test_refs_reflog_drop__can_drop_the_oldest_entry(void);
extern void test_refs_reflog_drop__can_drop_the_oldest_entry_and_rewrite_the_log_history(void);
extern void test_refs_reflog_drop__can_drop_all_the_entries(void);
extern void test_refs_reflog_drop__can_persist_deletion_on_disk(void);
extern void test_refs_reflog_drop__initialize(void);
extern void test_refs_reflog_drop__cleanup(void);
extern void test_online_push__noop(void);
extern void test_online_push__b1(void);
extern void test_online_push__b2(void);
extern void test_online_push__b3(void);
extern void test_online_push__b4(void);
extern void test_online_push__b5(void);
extern void test_online_push__multi(void);
extern void test_online_push__implicit_tgt(void);
extern void test_online_push__fast_fwd(void);
extern void test_online_push__tag_commit(void);
extern void test_online_push__tag_tree(void);
extern void test_online_push__tag_blob(void);
extern void test_online_push__tag_lightweight(void);
extern void test_online_push__tag_to_tag(void);
extern void test_online_push__force(void);
extern void test_online_push__delete(void);
extern void test_online_push__bad_refspecs(void);
extern void test_online_push__expressions(void);
extern void test_online_push__notes(void);
extern void test_online_push__initialize(void);
extern void test_online_push__cleanup(void);
extern void test_trace_trace__sets(void);
extern void test_trace_trace__can_reset(void);
extern void test_trace_trace__can_unset(void);
extern void test_trace_trace__skips_higher_level(void);
extern void test_trace_trace__writes(void);
extern void test_trace_trace__writes_lower_level(void);
extern void test_trace_trace__initialize(void);
extern void test_trace_trace__cleanup(void);
extern void test_object_tree_read__loaded(void);
extern void test_object_tree_read__two(void);
extern void test_object_tree_read__initialize(void);
extern void test_object_tree_read__cleanup(void);
extern void test_index_rename__single_file(void);
extern void test_blame_buffer__added_line(void);
extern void test_blame_buffer__deleted_line(void);
extern void test_blame_buffer__add_splits_hunk(void);
extern void test_blame_buffer__delete_crosses_hunk_boundary(void);
extern void test_blame_buffer__replace_line(void);
extern void test_blame_buffer__add_lines_at_end(void);
extern void test_blame_buffer__initialize(void);
extern void test_blame_buffer__cleanup(void);
extern void test_status_worktree_init__cannot_retrieve_the_status_of_a_bare_repository(void);
extern void test_status_worktree_init__first_commit_in_progress(void);
extern void test_status_worktree_init__status_file_without_index_or_workdir(void);
extern void test_status_worktree_init__status_file_with_clean_index_and_empty_workdir(void);
extern void test_status_worktree_init__bracket_in_filename(void);
extern void test_status_worktree_init__space_in_filename(void);
extern void test_status_worktree_init__disable_pathspec_match(void);
extern void test_status_worktree_init__new_staged_file_must_handle_crlf(void);
extern void test_pack_packbuilder__create_pack(void);
extern void test_pack_packbuilder__get_hash(void);
extern void test_pack_packbuilder__permissions_standard(void);
extern void test_pack_packbuilder__permissions_readonly(void);
extern void test_pack_packbuilder__permissions_readwrite(void);
extern void test_pack_packbuilder__foreach(void);
extern void test_pack_packbuilder__initialize(void);
extern void test_pack_packbuilder__cleanup(void);
extern void test_diff_index__0(void);
extern void test_diff_index__1(void);
extern void test_diff_index__checks_options_version(void);
extern void test_diff_index__initialize(void);
extern void test_diff_index__cleanup(void);
extern void test_object_raw_size__validate_oid_size(void);
extern void test_revwalk_basic__sorting_modes(void);
extern void test_revwalk_basic__glob_heads(void);
extern void test_revwalk_basic__glob_heads_with_invalid(void);
extern void test_revwalk_basic__push_head(void);
extern void test_revwalk_basic__push_head_hide_ref(void);
extern void test_revwalk_basic__push_head_hide_ref_nobase(void);
extern void test_revwalk_basic__disallow_non_commit(void);
extern void test_revwalk_basic__push_range(void);
extern void test_revwalk_basic__initialize(void);
extern void test_revwalk_basic__cleanup(void);
extern void test_object_raw_hash__hash_by_blocks(void);
extern void test_object_raw_hash__hash_buffer_in_single_call(void);
extern void test_object_raw_hash__hash_vector(void);
extern void test_object_raw_hash__hash_junk_data(void);
extern void test_object_raw_hash__hash_commit_object(void);
extern void test_object_raw_hash__hash_tree_object(void);
extern void test_object_raw_hash__hash_tag_object(void);
extern void test_object_raw_hash__hash_zero_length_object(void);
extern void test_object_raw_hash__hash_one_byte_object(void);
extern void test_object_raw_hash__hash_two_byte_object(void);
extern void test_object_raw_hash__hash_multi_byte_object(void);
extern void test_checkout_binaryunicode__noautocrlf(void);
extern void test_checkout_binaryunicode__autocrlf(void);
extern void test_checkout_binaryunicode__initialize(void);
extern void test_checkout_binaryunicode__cleanup(void);
extern void test_refs_peel__can_peel_a_tag(void);
extern void test_refs_peel__can_peel_a_branch(void);
extern void test_refs_peel__can_peel_a_symbolic_reference(void);
extern void test_refs_peel__cannot_peel_into_a_non_existing_target(void);
extern void test_refs_peel__can_peel_into_any_non_tag_object(void);
extern void test_refs_peel__can_peel_fully_peeled_packed_refs(void);
extern void test_refs_peel__initialize(void);
extern void test_refs_peel__cleanup(void);
extern void test_submodule_modify__add(void);
extern void test_submodule_modify__init(void);
extern void test_submodule_modify__sync(void);
extern void test_submodule_modify__edit_and_save(void);
extern void test_submodule_modify__initialize(void);
extern void test_object_blob_filter__unfiltered(void);
extern void test_object_blob_filter__stats(void);
extern void test_object_blob_filter__to_odb(void);
extern void test_object_blob_filter__initialize(void);
extern void test_object_blob_filter__cleanup(void);
extern void test_network_cred__stock_userpass_validates_args(void);
extern void test_network_cred__stock_userpass_validates_that_method_is_allowed(void);
extern void test_network_cred__stock_userpass_properly_handles_username_in_url(void);
extern void test_core_strtol__int32(void);
extern void test_core_strtol__int64(void);
extern void test_refs_branches_lookup__can_retrieve_a_local_branch(void);
extern void test_refs_branches_lookup__can_retrieve_a_remote_tracking_branch(void);
extern void test_refs_branches_lookup__trying_to_retrieve_an_unknown_branch_returns_ENOTFOUND(void);
extern void test_refs_branches_lookup__trying_to_retrieve_a_branch_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_branches_lookup__initialize(void);
extern void test_refs_branches_lookup__cleanup(void);
extern void test_core_stat__0(void);
extern void test_core_stat__initialize(void);
extern void test_core_stat__cleanup(void);
extern void test_core_pool__0(void);
extern void test_core_pool__1(void);
extern void test_core_pool__2(void);
extern void test_core_pool__free_list(void);
extern void test_core_pool__strndup_limit(void);
extern void test_stash_foreach__enumerating_a_empty_repository_doesnt_fail(void);
extern void test_stash_foreach__can_enumerate_a_repository(void);
extern void test_stash_foreach__initialize(void);
extern void test_stash_foreach__cleanup(void);
extern void test_status_single__hash_single_file(void);
extern void test_status_single__hash_single_empty_file(void);
extern void test_notes_notes__can_retrieve_a_list_of_notes_for_a_given_namespace(void);
extern void test_notes_notes__can_cancel_foreach(void);
extern void test_notes_notes__retrieving_a_list_of_notes_for_an_unknown_namespace_returns_ENOTFOUND(void);
extern void test_notes_notes__inserting_a_note_without_passing_a_namespace_uses_the_default_namespace(void);
extern void test_notes_notes__can_insert_a_note_with_a_custom_namespace(void);
extern void test_notes_notes__creating_a_note_on_a_target_which_already_has_one_returns_EEXISTS(void);
extern void test_notes_notes__creating_a_note_on_a_target_can_overwrite_existing_note(void);
extern void test_notes_notes__can_insert_a_note_in_an_existing_fanout(void);
extern void test_notes_notes__can_read_a_note_in_an_existing_fanout(void);
extern void test_notes_notes__can_remove_a_note_in_an_existing_fanout(void);
extern void test_notes_notes__removing_a_note_which_doesnt_exists_returns_ENOTFOUND(void);
extern void test_notes_notes__can_iterate_default_namespace(void);
extern void test_notes_notes__can_iterate_custom_namespace(void);
extern void test_notes_notes__empty_iterate(void);
extern void test_notes_notes__initialize(void);
extern void test_notes_notes__cleanup(void);
extern void test_reset_soft__can_reset_the_non_detached_Head_to_the_specified_commit(void);
extern void test_reset_soft__can_reset_the_detached_Head_to_the_specified_commit(void);
extern void test_reset_soft__resetting_to_the_commit_pointed_at_by_the_Head_does_not_change_the_target_of_the_Head(void);
extern void test_reset_soft__resetting_to_a_tag_sets_the_Head_to_the_peeled_commit(void);
extern void test_reset_soft__cannot_reset_to_a_tag_not_pointing_at_a_commit(void);
extern void test_reset_soft__resetting_against_an_unborn_head_repo_makes_the_head_no_longer_unborn(void);
extern void test_reset_soft__fails_when_merging(void);
extern void test_reset_soft__fails_when_index_contains_conflicts_independently_of_MERGE_HEAD_file_existence(void);
extern void test_reset_soft__initialize(void);
extern void test_reset_soft__cleanup(void);
extern void test_object_tree_frompath__retrieve_tree_from_path_to_treeentry(void);
extern void test_object_tree_frompath__fail_when_processing_an_invalid_path(void);
extern void test_object_tree_frompath__initialize(void);
extern void test_object_tree_frompath__cleanup(void);
extern void test_refs_delete__packed_loose(void);
extern void test_refs_delete__packed_only(void);
extern void test_refs_delete__initialize(void);
extern void test_refs_delete__cleanup(void);
extern void test_merge_trees_treediff__simple(void);
extern void test_merge_trees_treediff__df_conflicts(void);
extern void test_merge_trees_treediff__strict_renames(void);
extern void test_merge_trees_treediff__rename_conflicts(void);
extern void test_merge_trees_treediff__best_renames(void);
extern void test_merge_trees_treediff__initialize(void);
extern void test_merge_trees_treediff__cleanup(void);
extern void test_online_fetch__default_git(void);
extern void test_online_fetch__default_http(void);
extern void test_online_fetch__default_https(void);
extern void test_online_fetch__no_tags_git(void);
extern void test_online_fetch__no_tags_http(void);
extern void test_online_fetch__doesnt_retrieve_a_pack_when_the_repository_is_up_to_date(void);
extern void test_online_fetch__can_cancel(void);
extern void test_online_fetch__ls_disconnected(void);
extern void test_online_fetch__initialize(void);
extern void test_online_fetch__cleanup(void);
extern void test_object_lookupbypath__errors(void);
extern void test_object_lookupbypath__from_root_tree(void);
extern void test_object_lookupbypath__from_head_commit(void);
extern void test_object_lookupbypath__from_subdir_tree(void);
extern void test_object_lookupbypath__initialize(void);
extern void test_object_lookupbypath__cleanup(void);
extern void test_object_tag_list__list_all(void);
extern void test_object_tag_list__list_by_pattern(void);
extern void test_object_tag_list__initialize(void);
extern void test_object_tag_list__cleanup(void);
extern void test_config_global__open_global(void);
extern void test_config_global__open_xdg(void);
extern void test_config_global__initialize(void);
extern void test_config_global__cleanup(void);
extern void test_buf_splice__preprend(void);
extern void test_buf_splice__append(void);
extern void test_buf_splice__insert_at(void);
extern void test_buf_splice__remove_at(void);
extern void test_buf_splice__replace(void);
extern void test_buf_splice__replace_with_longer(void);
extern void test_buf_splice__replace_with_shorter(void);
extern void test_buf_splice__truncate(void);
extern void test_buf_splice__dont_do_anything(void);
extern void test_buf_splice__initialize(void);
extern void test_buf_splice__cleanup(void);
extern void test_refs_branches_remote__can_get_remote_for_branch(void);
extern void test_refs_branches_remote__insufficient_buffer_returns_error(void);
extern void test_refs_branches_remote__no_matching_remote_returns_error(void);
extern void test_refs_branches_remote__local_remote_returns_error(void);
extern void test_refs_branches_remote__ambiguous_remote_returns_error(void);
extern void test_refs_branches_remote__initialize(void);
extern void test_refs_branches_remote__cleanup(void);
extern void test_stash_drop__cannot_drop_from_an_empty_stash(void);
extern void test_stash_drop__cannot_drop_a_non_existing_stashed_state(void);
extern void test_stash_drop__can_purge_the_stash_from_the_top(void);
extern void test_stash_drop__can_purge_the_stash_from_the_bottom(void);
extern void test_stash_drop__dropping_an_entry_rewrites_reflog_history(void);
extern void test_stash_drop__dropping_the_last_entry_removes_the_stash(void);
extern void test_stash_drop__dropping_the_top_stash_updates_the_stash_reference(void);
extern void test_stash_drop__initialize(void);
extern void test_stash_drop__cleanup(void);
extern void test_clone_empty__can_clone_an_empty_local_repo_barely(void);
extern void test_clone_empty__can_clone_an_empty_local_repo(void);
extern void test_clone_empty__can_clone_an_empty_standard_repo(void);
extern void test_clone_empty__initialize(void);
extern void test_clone_empty__cleanup(void);
extern void test_object_message__long_lines_without_spaces_should_be_unchanged(void);
extern void test_object_message__lines_with_spaces_at_the_beginning_should_be_unchanged(void);
extern void test_object_message__lines_with_intermediate_spaces_should_be_unchanged(void);
extern void test_object_message__consecutive_blank_lines_should_be_unified(void);
extern void test_object_message__only_consecutive_blank_lines_should_be_completely_removed(void);
extern void test_object_message__consecutive_blank_lines_at_the_beginning_should_be_removed(void);
extern void test_object_message__consecutive_blank_lines_at_the_end_should_be_removed(void);
extern void test_object_message__text_without_newline_at_end_should_end_with_newline(void);
extern void test_object_message__text_plus_spaces_without_newline_should_not_show_spaces_and_end_with_newline(void);
extern void test_object_message__text_plus_spaces_ending_with_newline_should_be_cleaned_and_newline_must_remain(void);
extern void test_object_message__spaces_with_newline_at_end_should_be_replaced_with_empty_string(void);
extern void test_object_message__spaces_without_newline_at_end_should_be_replaced_with_empty_string(void);
extern void test_object_message__consecutive_text_lines_should_be_unchanged(void);
extern void test_object_message__strip_comments(void);
extern void test_object_message__keep_comments(void);
extern void test_object_message__message_prettify(void);
extern void test_reset_mixed__cannot_reset_in_a_bare_repository(void);
extern void test_reset_mixed__resetting_refreshes_the_index_to_the_commit_tree(void);
extern void test_reset_mixed__initialize(void);
extern void test_reset_mixed__cleanup(void);
extern void test_object_lookup__lookup_wrong_type_returns_enotfound(void);
extern void test_object_lookup__lookup_nonexisting_returns_enotfound(void);
extern void test_object_lookup__lookup_wrong_type_by_abbreviated_id_returns_enotfound(void);
extern void test_object_lookup__lookup_wrong_type_eventually_returns_enotfound(void);
extern void test_object_lookup__initialize(void);
extern void test_object_lookup__cleanup(void);
extern void test_object_peel__peeling_an_object_into_its_own_type_returns_another_instance_of_it(void);
extern void test_object_peel__can_peel_a_tag(void);
extern void test_object_peel__can_peel_a_commit(void);
extern void test_object_peel__cannot_peel_a_tree(void);
extern void test_object_peel__cannot_peel_a_blob(void);
extern void test_object_peel__target_any_object_for_type_change(void);
extern void test_object_peel__initialize(void);
extern void test_object_peel__cleanup(void);
extern void test_repo_hashfile__simple(void);
extern void test_repo_hashfile__filtered(void);
extern void test_repo_hashfile__initialize(void);
extern void test_repo_hashfile__cleanup(void);
extern void test_core_vector__0(void);
extern void test_core_vector__1(void);
extern void test_core_vector__2(void);
extern void test_core_vector__3(void);
extern void test_core_vector__4(void);
extern void test_core_vector__5(void);
extern void test_core_vector__remove_matching(void);
extern void test_refs_branches_create__can_create_a_local_branch(void);
extern void test_refs_branches_create__can_not_create_a_branch_if_its_name_collide_with_an_existing_one(void);
extern void test_refs_branches_create__can_force_create_over_an_existing_branch(void);
extern void test_refs_branches_create__creating_a_branch_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_branches_create__initialize(void);
extern void test_refs_branches_create__cleanup(void);
extern void test_object_raw_write__loose_object(void);
extern void test_object_raw_write__loose_tree(void);
extern void test_object_raw_write__loose_tag(void);
extern void test_object_raw_write__zero_length(void);
extern void test_object_raw_write__one_byte(void);
extern void test_object_raw_write__two_byte(void);
extern void test_object_raw_write__several_bytes(void);
extern void test_refs_foreachglob__retrieve_all_refs(void);
extern void test_refs_foreachglob__retrieve_remote_branches(void);
extern void test_refs_foreachglob__retrieve_local_branches(void);
extern void test_refs_foreachglob__retrieve_partially_named_references(void);
extern void test_refs_foreachglob__can_cancel(void);
extern void test_refs_foreachglob__initialize(void);
extern void test_refs_foreachglob__cleanup(void);
extern void test_repo_headtree__can_retrieve_the_root_tree_from_a_detached_head(void);
extern void test_repo_headtree__can_retrieve_the_root_tree_from_a_non_detached_head(void);
extern void test_repo_headtree__when_head_is_unborn_returns_EUNBORNBRANCH(void);
extern void test_repo_headtree__when_head_is_missing_returns_ENOTFOUND(void);
extern void test_repo_headtree__initialize(void);
extern void test_repo_headtree__cleanup(void);
extern void test_attr_lookup__simple(void);
extern void test_attr_lookup__match_variants(void);
extern void test_attr_lookup__assign_variants(void);
extern void test_attr_lookup__check_attr_examples(void);
extern void test_attr_lookup__from_buffer(void);
extern void test_config_read__simple_read(void);
extern void test_config_read__case_sensitive(void);
extern void test_config_read__multiline_value(void);
extern void test_config_read__subsection_header(void);
extern void test_config_read__lone_variable(void);
extern void test_config_read__number_suffixes(void);
extern void test_config_read__blank_lines(void);
extern void test_config_read__invalid_ext_headers(void);
extern void test_config_read__empty_files(void);
extern void test_config_read__symbol_headers(void);
extern void test_config_read__header_in_last_line(void);
extern void test_config_read__prefixes(void);
extern void test_config_read__escaping_quotes(void);
extern void test_config_read__foreach(void);
extern void test_config_read__iterator(void);
extern void test_config_read__foreach_match(void);
extern void test_config_read__iterator_glob(void);
extern void test_config_read__whitespace_not_required_around_assignment(void);
extern void test_config_read__read_git_config_entry(void);
extern void test_config_read__local_config_overrides_global_config_overrides_system_config(void);
extern void test_config_read__fallback_from_local_to_global_and_from_global_to_system(void);
extern void test_config_read__simple_read_from_specific_level(void);
extern void test_config_read__can_load_and_parse_an_empty_config_file(void);
extern void test_config_read__corrupt_header(void);
extern void test_config_read__corrupt_header2(void);
extern void test_config_read__corrupt_header3(void);
extern void test_config_read__override_variable(void);
extern void test_config_add__to_existing_section(void);
extern void test_config_add__to_new_section(void);
extern void test_config_add__initialize(void);
extern void test_config_add__cleanup(void);
extern void test_online_fetchhead__wildcard_spec(void);
extern void test_online_fetchhead__explicit_spec(void);
extern void test_online_fetchhead__no_merges(void);
extern void test_online_fetchhead__initialize(void);
extern void test_online_fetchhead__cleanup(void);
static const struct clar_func _clar_cb_refs_normalize[] = {
    { "can_normalize_a_direct_reference_name", &test_refs_normalize__can_normalize_a_direct_reference_name },
    { "cannot_normalize_any_direct_reference_name", &test_refs_normalize__cannot_normalize_any_direct_reference_name },
    { "symbolic", &test_refs_normalize__symbolic },
    { "jgit_suite", &test_refs_normalize__jgit_suite },
    { "buffer_has_to_be_big_enough_to_hold_the_normalized_version", &test_refs_normalize__buffer_has_to_be_big_enough_to_hold_the_normalized_version },
    { "refspec_pattern", &test_refs_normalize__refspec_pattern }
};
static const struct clar_func _clar_cb_repo_pathspec[] = {
    { "workdir0", &test_repo_pathspec__workdir0 },
    { "workdir1", &test_repo_pathspec__workdir1 },
    { "workdir2", &test_repo_pathspec__workdir2 },
    { "workdir3", &test_repo_pathspec__workdir3 },
    { "workdir4", &test_repo_pathspec__workdir4 },
    { "index0", &test_repo_pathspec__index0 },
    { "index1", &test_repo_pathspec__index1 },
    { "tree0", &test_repo_pathspec__tree0 },
    { "tree5", &test_repo_pathspec__tree5 },
    { "in_memory", &test_repo_pathspec__in_memory }
};
static const struct clar_func _clar_cb_odb_alternates[] = {
    { "chained", &test_odb_alternates__chained },
    { "long_chain", &test_odb_alternates__long_chain }
};
static const struct clar_func _clar_cb_object_blob_write[] = {
    { "can_create_a_blob_in_a_standard_repo_from_a_file_located_in_the_working_directory", &test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_file_located_in_the_working_directory },
    { "can_create_a_blob_in_a_standard_repo_from_a_absolute_filepath_pointing_outside_of_the_working_directory", &test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_absolute_filepath_pointing_outside_of_the_working_directory },
    { "can_create_a_blob_in_a_bare_repo_from_a_absolute_filepath", &test_object_blob_write__can_create_a_blob_in_a_bare_repo_from_a_absolute_filepath }
};
static const struct clar_func _clar_cb_core_posix[] = {
    { "inet_pton", &test_core_posix__inet_pton }
};
static const struct clar_func _clar_cb_threads_basic[] = {
    { "cache", &test_threads_basic__cache },
    { "multiple_init", &test_threads_basic__multiple_init }
};
static const struct clar_func _clar_cb_core_env[] = {
    { "0", &test_core_env__0 },
    { "1", &test_core_env__1 },
    { "2", &test_core_env__2 }
};
static const struct clar_func _clar_cb_odb_backend_nonrefreshing[] = {
    { "exists_is_invoked_once_on_failure", &test_odb_backend_nonrefreshing__exists_is_invoked_once_on_failure },
    { "read_is_invoked_once_on_failure", &test_odb_backend_nonrefreshing__read_is_invoked_once_on_failure },
    { "readprefix_is_invoked_once_on_failure", &test_odb_backend_nonrefreshing__readprefix_is_invoked_once_on_failure },
    { "readheader_is_invoked_once_on_failure", &test_odb_backend_nonrefreshing__readheader_is_invoked_once_on_failure },
    { "exists_is_invoked_once_on_success", &test_odb_backend_nonrefreshing__exists_is_invoked_once_on_success },
    { "read_is_invoked_once_on_success", &test_odb_backend_nonrefreshing__read_is_invoked_once_on_success },
    { "readprefix_is_invoked_once_on_success", &test_odb_backend_nonrefreshing__readprefix_is_invoked_once_on_success },
    { "readheader_is_invoked_once_on_success", &test_odb_backend_nonrefreshing__readheader_is_invoked_once_on_success },
    { "read_is_invoked_once_when_revparsing_a_full_oid", &test_odb_backend_nonrefreshing__read_is_invoked_once_when_revparsing_a_full_oid }
};
static const struct clar_func _clar_cb_online_clone[] = {
    { "network_full", &test_online_clone__network_full },
    { "network_bare", &test_online_clone__network_bare },
    { "empty_repository", &test_online_clone__empty_repository },
    { "can_checkout_a_cloned_repo", &test_online_clone__can_checkout_a_cloned_repo },
    { "clone_into", &test_online_clone__clone_into },
    { "custom_remote_callbacks", &test_online_clone__custom_remote_callbacks },
    { "cred_callback_failure_is_euser", &test_online_clone__cred_callback_failure_is_euser },
    { "credentials", &test_online_clone__credentials },
    { "bitbucket_style", &test_online_clone__bitbucket_style },
    { "assembla_style", &test_online_clone__assembla_style },
    { "can_cancel", &test_online_clone__can_cancel }
};
static const struct clar_func _clar_cb_repo_getters[] = {
    { "is_empty_correctly_deals_with_pristine_looking_repos", &test_repo_getters__is_empty_correctly_deals_with_pristine_looking_repos },
    { "is_empty_can_detect_used_repositories", &test_repo_getters__is_empty_can_detect_used_repositories },
    { "retrieving_the_odb_honors_the_refcount", &test_repo_getters__retrieving_the_odb_honors_the_refcount }
};
static const struct clar_func _clar_cb_merge_trees_modeconflict[] = {
    { "df_conflict", &test_merge_trees_modeconflict__df_conflict }
};
static const struct clar_func _clar_cb_odb_loose[] = {
    { "exists", &test_odb_loose__exists },
    { "simple_reads", &test_odb_loose__simple_reads },
    { "permissions_standard", &test_odb_loose__permissions_standard },
    { "permissions_readwrite", &test_odb_loose__permissions_readwrite }
};
static const struct clar_func _clar_cb_repo_open[] = {
    { "bare_empty_repo", &test_repo_open__bare_empty_repo },
    { "standard_empty_repo_through_gitdir", &test_repo_open__standard_empty_repo_through_gitdir },
    { "standard_empty_repo_through_workdir", &test_repo_open__standard_empty_repo_through_workdir },
    { "open_with_discover", &test_repo_open__open_with_discover },
    { "gitlinked", &test_repo_open__gitlinked },
    { "from_git_new_workdir", &test_repo_open__from_git_new_workdir },
    { "failures", &test_repo_open__failures },
    { "bad_gitlinks", &test_repo_open__bad_gitlinks },
    { "win32_path", &test_repo_open__win32_path },
    { "opening_a_non_existing_repository_returns_ENOTFOUND", &test_repo_open__opening_a_non_existing_repository_returns_ENOTFOUND },
    { "no_config", &test_repo_open__no_config },
    { "force_bare", &test_repo_open__force_bare }
};
static const struct clar_func _clar_cb_merge_workdir_renames[] = {
    { "renames", &test_merge_workdir_renames__renames },
    { "ours", &test_merge_workdir_renames__ours },
    { "similar", &test_merge_workdir_renames__similar }
};
static const struct clar_func _clar_cb_config_refresh[] = {
    { "update_value", &test_config_refresh__update_value },
    { "delete_value", &test_config_refresh__delete_value }
};
static const struct clar_func _clar_cb_revwalk_mergebase[] = {
    { "single1", &test_revwalk_mergebase__single1 },
    { "single2", &test_revwalk_mergebase__single2 },
    { "merged_branch", &test_revwalk_mergebase__merged_branch },
    { "two_way_merge", &test_revwalk_mergebase__two_way_merge },
    { "no_common_ancestor_returns_ENOTFOUND", &test_revwalk_mergebase__no_common_ancestor_returns_ENOTFOUND },
    { "prefer_youngest_merge_base", &test_revwalk_mergebase__prefer_youngest_merge_base },
    { "no_off_by_one_missing", &test_revwalk_mergebase__no_off_by_one_missing },
    { "many_no_common_ancestor_returns_ENOTFOUND", &test_revwalk_mergebase__many_no_common_ancestor_returns_ENOTFOUND },
    { "many_merge_branch", &test_revwalk_mergebase__many_merge_branch }
};
static const struct clar_func _clar_cb_merge_workdir_setup[] = {
    { "one_branch", &test_merge_workdir_setup__one_branch },
    { "no_fastforward", &test_merge_workdir_setup__no_fastforward },
    { "one_oid", &test_merge_workdir_setup__one_oid },
    { "two_branches", &test_merge_workdir_setup__two_branches },
    { "three_branches", &test_merge_workdir_setup__three_branches },
    { "three_oids", &test_merge_workdir_setup__three_oids },
    { "branches_and_oids_1", &test_merge_workdir_setup__branches_and_oids_1 },
    { "branches_and_oids_2", &test_merge_workdir_setup__branches_and_oids_2 },
    { "branches_and_oids_3", &test_merge_workdir_setup__branches_and_oids_3 },
    { "branches_and_oids_4", &test_merge_workdir_setup__branches_and_oids_4 },
    { "three_same_branches", &test_merge_workdir_setup__three_same_branches },
    { "three_same_oids", &test_merge_workdir_setup__three_same_oids },
    { "remote_tracking_one_branch", &test_merge_workdir_setup__remote_tracking_one_branch },
    { "remote_tracking_two_branches", &test_merge_workdir_setup__remote_tracking_two_branches },
    { "remote_tracking_three_branches", &test_merge_workdir_setup__remote_tracking_three_branches },
    { "normal_branch_and_remote_tracking_branch", &test_merge_workdir_setup__normal_branch_and_remote_tracking_branch },
    { "remote_tracking_branch_and_normal_branch", &test_merge_workdir_setup__remote_tracking_branch_and_normal_branch },
    { "two_remote_tracking_branch_and_two_normal_branches", &test_merge_workdir_setup__two_remote_tracking_branch_and_two_normal_branches },
    { "pull_one", &test_merge_workdir_setup__pull_one },
    { "pull_two", &test_merge_workdir_setup__pull_two },
    { "pull_three", &test_merge_workdir_setup__pull_three },
    { "three_remotes", &test_merge_workdir_setup__three_remotes },
    { "two_remotes", &test_merge_workdir_setup__two_remotes },
    { "head_notfound", &test_merge_workdir_setup__head_notfound },
    { "head_invalid_oid", &test_merge_workdir_setup__head_invalid_oid },
    { "head_foreach_nonewline", &test_merge_workdir_setup__head_foreach_nonewline },
    { "head_foreach_one", &test_merge_workdir_setup__head_foreach_one },
    { "head_foreach_octopus", &test_merge_workdir_setup__head_foreach_octopus },
    { "retained_after_success", &test_merge_workdir_setup__retained_after_success },
    { "removed_after_failure", &test_merge_workdir_setup__removed_after_failure }
};
static const struct clar_func _clar_cb_refs_setter[] = {
    { "update_direct", &test_refs_setter__update_direct },
    { "update_symbolic", &test_refs_setter__update_symbolic },
    { "cant_update_direct_with_symbolic", &test_refs_setter__cant_update_direct_with_symbolic },
    { "cant_update_symbolic_with_direct", &test_refs_setter__cant_update_symbolic_with_direct }
};
static const struct clar_func _clar_cb_repo_head[] = {
    { "head_detached", &test_repo_head__head_detached },
    { "unborn_head", &test_repo_head__unborn_head },
    { "set_head_Attaches_HEAD_to_un_unborn_branch_when_the_branch_doesnt_exist", &test_repo_head__set_head_Attaches_HEAD_to_un_unborn_branch_when_the_branch_doesnt_exist },
    { "set_head_Returns_ENOTFOUND_when_the_reference_doesnt_exist", &test_repo_head__set_head_Returns_ENOTFOUND_when_the_reference_doesnt_exist },
    { "set_head_Fails_when_the_reference_points_to_a_non_commitish", &test_repo_head__set_head_Fails_when_the_reference_points_to_a_non_commitish },
    { "set_head_Attaches_HEAD_when_the_reference_points_to_a_branch", &test_repo_head__set_head_Attaches_HEAD_when_the_reference_points_to_a_branch },
    { "set_head_Detaches_HEAD_when_the_reference_doesnt_point_to_a_branch", &test_repo_head__set_head_Detaches_HEAD_when_the_reference_doesnt_point_to_a_branch },
    { "set_head_detached_Return_ENOTFOUND_when_the_object_doesnt_exist", &test_repo_head__set_head_detached_Return_ENOTFOUND_when_the_object_doesnt_exist },
    { "set_head_detached_Fails_when_the_object_isnt_a_commitish", &test_repo_head__set_head_detached_Fails_when_the_object_isnt_a_commitish },
    { "set_head_detached_Detaches_HEAD_and_make_it_point_to_the_peeled_commit", &test_repo_head__set_head_detached_Detaches_HEAD_and_make_it_point_to_the_peeled_commit },
    { "detach_head_Detaches_HEAD_and_make_it_point_to_the_peeled_commit", &test_repo_head__detach_head_Detaches_HEAD_and_make_it_point_to_the_peeled_commit },
    { "detach_head_Fails_if_HEAD_and_point_to_a_non_commitish", &test_repo_head__detach_head_Fails_if_HEAD_and_point_to_a_non_commitish },
    { "detaching_an_unborn_branch_returns_GIT_EUNBORNBRANCH", &test_repo_head__detaching_an_unborn_branch_returns_GIT_EUNBORNBRANCH },
    { "retrieving_an_unborn_branch_returns_GIT_EUNBORNBRANCH", &test_repo_head__retrieving_an_unborn_branch_returns_GIT_EUNBORNBRANCH },
    { "retrieving_a_missing_head_returns_GIT_ENOTFOUND", &test_repo_head__retrieving_a_missing_head_returns_GIT_ENOTFOUND },
    { "can_tell_if_an_unborn_head_is_detached", &test_repo_head__can_tell_if_an_unborn_head_is_detached }
};
static const struct clar_func _clar_cb_diff_pathspec[] = {
    { "0", &test_diff_pathspec__0 }
};
static const struct clar_func _clar_cb_submodule_status[] = {
    { "unchanged", &test_submodule_status__unchanged },
    { "ignore_none", &test_submodule_status__ignore_none },
    { "ignore_untracked", &test_submodule_status__ignore_untracked },
    { "ignore_dirty", &test_submodule_status__ignore_dirty },
    { "ignore_all", &test_submodule_status__ignore_all },
    { "iterator", &test_submodule_status__iterator },
    { "untracked_dirs_containing_ignored_files", &test_submodule_status__untracked_dirs_containing_ignored_files }
};
static const struct clar_func _clar_cb_checkout_typechange[] = {
    { "checkout_typechanges_safe", &test_checkout_typechange__checkout_typechanges_safe },
    { "checkout_with_conflicts", &test_checkout_typechange__checkout_with_conflicts }
};
static const struct clar_func _clar_cb_core_strmap[] = {
    { "0", &test_core_strmap__0 },
    { "1", &test_core_strmap__1 },
    { "2", &test_core_strmap__2 },
    { "3", &test_core_strmap__3 }
};
static const struct clar_func _clar_cb_core_oidmap[] = {
    { "basic", &test_core_oidmap__basic },
    { "hash_collision", &test_core_oidmap__hash_collision }
};
static const struct clar_func _clar_cb_refs_branches_iterator[] = {
    { "retrieve_all_branches", &test_refs_branches_iterator__retrieve_all_branches },
    { "retrieve_remote_branches", &test_refs_branches_iterator__retrieve_remote_branches },
    { "retrieve_local_branches", &test_refs_branches_iterator__retrieve_local_branches },
    { "retrieve_remote_symbolic_HEAD_when_present", &test_refs_branches_iterator__retrieve_remote_symbolic_HEAD_when_present },
    { "mix_of_packed_and_loose", &test_refs_branches_iterator__mix_of_packed_and_loose }
};
static const struct clar_func _clar_cb_config_include[] = {
    { "relative", &test_config_include__relative },
    { "absolute", &test_config_include__absolute },
    { "homedir", &test_config_include__homedir },
    { "refresh", &test_config_include__refresh },
    { "ordering", &test_config_include__ordering },
    { "depth", &test_config_include__depth }
};
static const struct clar_func _clar_cb_core_iconv[] = {
    { "unchanged", &test_core_iconv__unchanged },
    { "decomposed_to_precomposed", &test_core_iconv__decomposed_to_precomposed },
    { "precomposed_is_unmodified", &test_core_iconv__precomposed_is_unmodified }
};
static const struct clar_func _clar_cb_revwalk_simplify[] = {
    { "first_parent", &test_revwalk_simplify__first_parent }
};
static const struct clar_func _clar_cb_core_filebuf[] = {
    { "0", &test_core_filebuf__0 },
    { "1", &test_core_filebuf__1 },
    { "2", &test_core_filebuf__2 },
    { "4", &test_core_filebuf__4 },
    { "5", &test_core_filebuf__5 },
    { "umask", &test_core_filebuf__umask }
};
static const struct clar_func _clar_cb_commit_signature[] = {
    { "leading_and_trailing_spaces_are_trimmed", &test_commit_signature__leading_and_trailing_spaces_are_trimmed },
    { "angle_brackets_in_names_are_not_supported", &test_commit_signature__angle_brackets_in_names_are_not_supported },
    { "angle_brackets_in_email_are_not_supported", &test_commit_signature__angle_brackets_in_email_are_not_supported },
    { "create_empties", &test_commit_signature__create_empties },
    { "create_one_char", &test_commit_signature__create_one_char },
    { "create_two_char", &test_commit_signature__create_two_char },
    { "create_zero_char", &test_commit_signature__create_zero_char }
};
static const struct clar_func _clar_cb_diff_rename[] = {
    { "match_oid", &test_diff_rename__match_oid },
    { "checks_options_version", &test_diff_rename__checks_options_version },
    { "not_exact_match", &test_diff_rename__not_exact_match },
    { "handles_small_files", &test_diff_rename__handles_small_files },
    { "working_directory_changes", &test_diff_rename__working_directory_changes },
    { "patch", &test_diff_rename__patch },
    { "file_exchange", &test_diff_rename__file_exchange },
    { "file_exchange_three", &test_diff_rename__file_exchange_three },
    { "file_partial_exchange", &test_diff_rename__file_partial_exchange },
    { "rename_and_copy_from_same_source", &test_diff_rename__rename_and_copy_from_same_source },
    { "from_deleted_to_split", &test_diff_rename__from_deleted_to_split },
    { "rejected_match_can_match_others", &test_diff_rename__rejected_match_can_match_others },
    { "rejected_match_can_match_others_two", &test_diff_rename__rejected_match_can_match_others_two },
    { "rejected_match_can_match_others_three", &test_diff_rename__rejected_match_can_match_others_three },
    { "can_rename_from_rewrite", &test_diff_rename__can_rename_from_rewrite },
    { "case_changes_are_split", &test_diff_rename__case_changes_are_split },
    { "unmodified_can_be_renamed", &test_diff_rename__unmodified_can_be_renamed },
    { "rewrite_on_single_file", &test_diff_rename__rewrite_on_single_file }
};
static const struct clar_func _clar_cb_refs_create[] = {
    { "symbolic", &test_refs_create__symbolic },
    { "deep_symbolic", &test_refs_create__deep_symbolic },
    { "oid", &test_refs_create__oid },
    { "oid_unknown", &test_refs_create__oid_unknown },
    { "propagate_eexists", &test_refs_create__propagate_eexists },
    { "creating_a_reference_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_create__creating_a_reference_with_an_invalid_name_returns_EINVALIDSPEC }
};
static const struct clar_func _clar_cb_refs_lookup[] = {
    { "with_resolve", &test_refs_lookup__with_resolve },
    { "invalid_name", &test_refs_lookup__invalid_name },
    { "oid", &test_refs_lookup__oid },
    { "namespace", &test_refs_lookup__namespace }
};
static const struct clar_func _clar_cb_refs_unicode[] = {
    { "create_and_lookup", &test_refs_unicode__create_and_lookup }
};
static const struct clar_func _clar_cb_core_hex[] = {
    { "fromhex", &test_core_hex__fromhex }
};
static const struct clar_func _clar_cb_object_tag_peel[] = {
    { "can_peel_to_a_commit", &test_object_tag_peel__can_peel_to_a_commit },
    { "can_peel_several_nested_tags_to_a_commit", &test_object_tag_peel__can_peel_several_nested_tags_to_a_commit },
    { "can_peel_to_a_non_commit", &test_object_tag_peel__can_peel_to_a_non_commit }
};
static const struct clar_func _clar_cb_object_raw_fromstr[] = {
    { "fail_on_invalid_oid_string", &test_object_raw_fromstr__fail_on_invalid_oid_string },
    { "succeed_on_valid_oid_string", &test_object_raw_fromstr__succeed_on_valid_oid_string }
};
static const struct clar_func _clar_cb_core_string[] = {
    { "0", &test_core_string__0 },
    { "1", &test_core_string__1 },
    { "2", &test_core_string__2 }
};
static const struct clar_func _clar_cb_core_caps[] = {
    { "0", &test_core_caps__0 }
};
static const struct clar_func _clar_cb_reset_hard[] = {
    { "resetting_reverts_modified_files", &test_reset_hard__resetting_reverts_modified_files },
    { "cannot_reset_in_a_bare_repository", &test_reset_hard__cannot_reset_in_a_bare_repository },
    { "resetting_reverts_unmerged", &test_reset_hard__resetting_reverts_unmerged },
    { "cleans_up_merge", &test_reset_hard__cleans_up_merge }
};
static const struct clar_func _clar_cb_object_raw_convert[] = {
    { "succeed_on_oid_to_string_conversion", &test_object_raw_convert__succeed_on_oid_to_string_conversion },
    { "succeed_on_oid_to_string_conversion_big", &test_object_raw_convert__succeed_on_oid_to_string_conversion_big },
    { "convert_oid_partially", &test_object_raw_convert__convert_oid_partially }
};
static const struct clar_func _clar_cb_diff_drivers[] = {
    { "patterns", &test_diff_drivers__patterns },
    { "long_lines", &test_diff_drivers__long_lines }
};
static const struct clar_func _clar_cb_status_worktree[] = {
    { "whole_repository", &test_status_worktree__whole_repository },
    { "show_index_and_workdir", &test_status_worktree__show_index_and_workdir },
    { "show_index_only", &test_status_worktree__show_index_only },
    { "show_workdir_only", &test_status_worktree__show_workdir_only },
    { "empty_repository", &test_status_worktree__empty_repository },
    { "purged_worktree", &test_status_worktree__purged_worktree },
    { "swap_subdir_and_file", &test_status_worktree__swap_subdir_and_file },
    { "swap_subdir_with_recurse_and_pathspec", &test_status_worktree__swap_subdir_with_recurse_and_pathspec },
    { "single_file", &test_status_worktree__single_file },
    { "single_nonexistent_file", &test_status_worktree__single_nonexistent_file },
    { "single_nonexistent_file_empty_repo", &test_status_worktree__single_nonexistent_file_empty_repo },
    { "single_file_empty_repo", &test_status_worktree__single_file_empty_repo },
    { "single_folder", &test_status_worktree__single_folder },
    { "ignores", &test_status_worktree__ignores },
    { "issue_592", &test_status_worktree__issue_592 },
    { "issue_592_2", &test_status_worktree__issue_592_2 },
    { "issue_592_3", &test_status_worktree__issue_592_3 },
    { "issue_592_4", &test_status_worktree__issue_592_4 },
    { "issue_592_5", &test_status_worktree__issue_592_5 },
    { "issue_592_ignores_0", &test_status_worktree__issue_592_ignores_0 },
    { "issue_592_ignored_dirs_with_tracked_content", &test_status_worktree__issue_592_ignored_dirs_with_tracked_content },
    { "conflict_with_diff3", &test_status_worktree__conflict_with_diff3 },
    { "filemode_changes", &test_status_worktree__filemode_changes },
    { "interruptable_foreach", &test_status_worktree__interruptable_foreach },
    { "line_endings_dont_count_as_changes_with_autocrlf", &test_status_worktree__line_endings_dont_count_as_changes_with_autocrlf },
    { "line_endings_dont_count_as_changes_with_autocrlf_issue_1397", &test_status_worktree__line_endings_dont_count_as_changes_with_autocrlf_issue_1397 },
    { "conflicted_item", &test_status_worktree__conflicted_item },
    { "file_status_honors_core_ignorecase_true", &test_status_worktree__file_status_honors_core_ignorecase_true },
    { "file_status_honors_core_ignorecase_false", &test_status_worktree__file_status_honors_core_ignorecase_false },
    { "file_status_honors_case_ignorecase_regarding_untracked_files", &test_status_worktree__file_status_honors_case_ignorecase_regarding_untracked_files },
    { "simple_delete", &test_status_worktree__simple_delete },
    { "simple_delete_indexed", &test_status_worktree__simple_delete_indexed },
    { "sorting_by_case", &test_status_worktree__sorting_by_case },
    { "long_filenames", &test_status_worktree__long_filenames }
};
static const struct clar_func _clar_cb_object_raw_short[] = {
    { "oid_shortener_no_duplicates", &test_object_raw_short__oid_shortener_no_duplicates },
    { "oid_shortener_stresstest_git_oid_shorten", &test_object_raw_short__oid_shortener_stresstest_git_oid_shorten },
    { "oid_shortener_too_much_oids", &test_object_raw_short__oid_shortener_too_much_oids }
};
static const struct clar_func _clar_cb_index_reuc[] = {
    { "add", &test_index_reuc__add },
    { "add_no_ancestor", &test_index_reuc__add_no_ancestor },
    { "read_bypath", &test_index_reuc__read_bypath },
    { "ignore_case", &test_index_reuc__ignore_case },
    { "read_byindex", &test_index_reuc__read_byindex },
    { "updates_existing", &test_index_reuc__updates_existing },
    { "remove", &test_index_reuc__remove },
    { "write", &test_index_reuc__write },
    { "cleaned_on_reset_hard", &test_index_reuc__cleaned_on_reset_hard },
    { "cleaned_on_reset_mixed", &test_index_reuc__cleaned_on_reset_mixed },
    { "retained_on_reset_soft", &test_index_reuc__retained_on_reset_soft },
    { "cleaned_on_checkout_tree", &test_index_reuc__cleaned_on_checkout_tree },
    { "cleaned_on_checkout_head", &test_index_reuc__cleaned_on_checkout_head },
    { "retained_on_checkout_index", &test_index_reuc__retained_on_checkout_index }
};
static const struct clar_func _clar_cb_core_path[] = {
    { "00_dirname", &test_core_path__00_dirname },
    { "01_basename", &test_core_path__01_basename },
    { "02_topdir", &test_core_path__02_topdir },
    { "05_joins", &test_core_path__05_joins },
    { "06_long_joins", &test_core_path__06_long_joins },
    { "07_path_to_dir", &test_core_path__07_path_to_dir },
    { "08_self_join", &test_core_path__08_self_join },
    { "09_percent_decode", &test_core_path__09_percent_decode },
    { "10_fromurl", &test_core_path__10_fromurl },
    { "11_walkup", &test_core_path__11_walkup },
    { "12_offset_to_path_root", &test_core_path__12_offset_to_path_root },
    { "13_cannot_prettify_a_non_existing_file", &test_core_path__13_cannot_prettify_a_non_existing_file },
    { "14_apply_relative", &test_core_path__14_apply_relative },
    { "15_resolve_relative", &test_core_path__15_resolve_relative }
};
static const struct clar_func _clar_cb_repo_setters[] = {
    { "setting_a_workdir_turns_a_bare_repository_into_a_standard_one", &test_repo_setters__setting_a_workdir_turns_a_bare_repository_into_a_standard_one },
    { "setting_a_workdir_prettifies_its_path", &test_repo_setters__setting_a_workdir_prettifies_its_path },
    { "setting_a_workdir_creates_a_gitlink", &test_repo_setters__setting_a_workdir_creates_a_gitlink },
    { "setting_a_new_index_on_a_repo_which_has_already_loaded_one_properly_honors_the_refcount", &test_repo_setters__setting_a_new_index_on_a_repo_which_has_already_loaded_one_properly_honors_the_refcount },
    { "setting_a_new_odb_on_a_repo_which_already_loaded_one_properly_honors_the_refcount", &test_repo_setters__setting_a_new_odb_on_a_repo_which_already_loaded_one_properly_honors_the_refcount }
};
static const struct clar_func _clar_cb_refs_revparse[] = {
    { "nonexistant_object", &test_refs_revparse__nonexistant_object },
    { "invalid_reference_name", &test_refs_revparse__invalid_reference_name },
    { "shas", &test_refs_revparse__shas },
    { "head", &test_refs_revparse__head },
    { "full_refs", &test_refs_revparse__full_refs },
    { "partial_refs", &test_refs_revparse__partial_refs },
    { "describe_output", &test_refs_revparse__describe_output },
    { "nth_parent", &test_refs_revparse__nth_parent },
    { "not_tag", &test_refs_revparse__not_tag },
    { "to_type", &test_refs_revparse__to_type },
    { "linear_history", &test_refs_revparse__linear_history },
    { "chaining", &test_refs_revparse__chaining },
    { "upstream", &test_refs_revparse__upstream },
    { "ordinal", &test_refs_revparse__ordinal },
    { "previous_head", &test_refs_revparse__previous_head },
    { "reflog_of_a_ref_under_refs", &test_refs_revparse__reflog_of_a_ref_under_refs },
    { "revwalk", &test_refs_revparse__revwalk },
    { "date", &test_refs_revparse__date },
    { "colon", &test_refs_revparse__colon },
    { "disambiguation", &test_refs_revparse__disambiguation },
    { "a_too_short_objectid_returns_EAMBIGUOUS", &test_refs_revparse__a_too_short_objectid_returns_EAMBIGUOUS },
    { "a_not_precise_enough_objectid_returns_EAMBIGUOUS", &test_refs_revparse__a_not_precise_enough_objectid_returns_EAMBIGUOUS },
    { "issue_994", &test_refs_revparse__issue_994 },
    { "try_to_retrieve_branch_before_described_tag", &test_refs_revparse__try_to_retrieve_branch_before_described_tag },
    { "try_to_retrieve_sha_before_branch", &test_refs_revparse__try_to_retrieve_sha_before_branch },
    { "try_to_retrieve_branch_before_abbrev_sha", &test_refs_revparse__try_to_retrieve_branch_before_abbrev_sha },
    { "range", &test_refs_revparse__range },
    { "parses_range_operator", &test_refs_revparse__parses_range_operator },
    { "ext_retrieves_both_the_reference_and_its_target", &test_refs_revparse__ext_retrieves_both_the_reference_and_its_target },
    { "ext_can_expand_short_reference_names", &test_refs_revparse__ext_can_expand_short_reference_names },
    { "ext_returns_NULL_reference_when_expression_points_at_a_revision", &test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_revision },
    { "ext_returns_NULL_reference_when_expression_points_at_a_tree_content", &test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_tree_content }
};
static const struct clar_func _clar_cb_index_names[] = {
    { "add", &test_index_names__add },
    { "roundtrip", &test_index_names__roundtrip },
    { "cleaned_on_reset_hard", &test_index_names__cleaned_on_reset_hard },
    { "cleaned_on_reset_mixed", &test_index_names__cleaned_on_reset_mixed },
    { "cleaned_on_checkout_tree", &test_index_names__cleaned_on_checkout_tree },
    { "cleaned_on_checkout_head", &test_index_names__cleaned_on_checkout_head },
    { "retained_on_checkout_index", &test_index_names__retained_on_checkout_index }
};
static const struct clar_func _clar_cb_commit_parent[] = {
    { "can_retrieve_nth_generation_parent", &test_commit_parent__can_retrieve_nth_generation_parent }
};
static const struct clar_func _clar_cb_object_tree_walk[] = {
    { "0", &test_object_tree_walk__0 },
    { "1", &test_object_tree_walk__1 },
    { "2", &test_object_tree_walk__2 }
};
static const struct clar_func _clar_cb_diff_patch[] = {
    { "can_properly_display_the_removal_of_a_file", &test_diff_patch__can_properly_display_the_removal_of_a_file },
    { "to_string", &test_diff_patch__to_string },
    { "config_options", &test_diff_patch__config_options },
    { "hunks_have_correct_line_numbers", &test_diff_patch__hunks_have_correct_line_numbers },
    { "line_counts_with_eofnl", &test_diff_patch__line_counts_with_eofnl }
};
static const struct clar_func _clar_cb_repo_shallow[] = {
    { "no_shallow_file", &test_repo_shallow__no_shallow_file },
    { "empty_shallow_file", &test_repo_shallow__empty_shallow_file },
    { "shallow_repo", &test_repo_shallow__shallow_repo }
};
static const struct clar_func _clar_cb_refs_iterator[] = {
    { "list", &test_refs_iterator__list },
    { "empty", &test_refs_iterator__empty }
};
static const struct clar_func _clar_cb_odb_sorting[] = {
    { "basic_backends_sorting", &test_odb_sorting__basic_backends_sorting },
    { "alternate_backends_sorting", &test_odb_sorting__alternate_backends_sorting }
};
static const struct clar_func _clar_cb_refs_rename[] = {
    { "loose", &test_refs_rename__loose },
    { "packed", &test_refs_rename__packed },
    { "packed_doesnt_pack_others", &test_refs_rename__packed_doesnt_pack_others },
    { "name_collision", &test_refs_rename__name_collision },
    { "invalid_name", &test_refs_rename__invalid_name },
    { "force_loose_packed", &test_refs_rename__force_loose_packed },
    { "force_loose", &test_refs_rename__force_loose },
    { "overwrite", &test_refs_rename__overwrite },
    { "prefix", &test_refs_rename__prefix },
    { "move_up", &test_refs_rename__move_up },
    { "propagate_eexists", &test_refs_rename__propagate_eexists }
};
static const struct clar_func _clar_cb_core_rmdir[] = {
    { "delete_recursive", &test_core_rmdir__delete_recursive },
    { "fail_to_delete_non_empty_dir", &test_core_rmdir__fail_to_delete_non_empty_dir },
    { "can_skip_non_empty_dir", &test_core_rmdir__can_skip_non_empty_dir },
    { "can_remove_empty_parents", &test_core_rmdir__can_remove_empty_parents }
};
static const struct clar_func _clar_cb_core_sortedcache[] = {
    { "name_only", &test_core_sortedcache__name_only },
    { "in_memory", &test_core_sortedcache__in_memory },
    { "on_disk", &test_core_sortedcache__on_disk }
};
static const struct clar_func _clar_cb_filter_custom[] = {
    { "to_odb", &test_filter_custom__to_odb },
    { "to_workdir", &test_filter_custom__to_workdir },
    { "can_register_a_custom_filter_in_the_repository", &test_filter_custom__can_register_a_custom_filter_in_the_repository },
    { "order_dependency", &test_filter_custom__order_dependency },
    { "filter_registry_failure_cases", &test_filter_custom__filter_registry_failure_cases }
};
static const struct clar_func _clar_cb_index_filemodes[] = {
    { "read", &test_index_filemodes__read },
    { "untrusted", &test_index_filemodes__untrusted },
    { "trusted", &test_index_filemodes__trusted }
};
static const struct clar_func _clar_cb_refs_listall[] = {
    { "from_repository_opened_through_workdir_path", &test_refs_listall__from_repository_opened_through_workdir_path },
    { "from_repository_opened_through_gitdir_path", &test_refs_listall__from_repository_opened_through_gitdir_path },
    { "from_repository_with_no_trailing_newline", &test_refs_listall__from_repository_with_no_trailing_newline }
};
static const struct clar_func _clar_cb_attr_ignore[] = {
    { "honor_temporary_rules", &test_attr_ignore__honor_temporary_rules },
    { "allow_root", &test_attr_ignore__allow_root },
    { "ignore_root", &test_attr_ignore__ignore_root },
    { "skip_gitignore_directory", &test_attr_ignore__skip_gitignore_directory },
    { "expand_tilde_to_homedir", &test_attr_ignore__expand_tilde_to_homedir }
};
static const struct clar_func _clar_cb_diff_diffiter[] = {
    { "create", &test_diff_diffiter__create },
    { "iterate_files_1", &test_diff_diffiter__iterate_files_1 },
    { "iterate_files_2", &test_diff_diffiter__iterate_files_2 },
    { "iterate_files_and_hunks", &test_diff_diffiter__iterate_files_and_hunks },
    { "max_size_threshold", &test_diff_diffiter__max_size_threshold },
    { "iterate_all", &test_diff_diffiter__iterate_all },
    { "iterate_randomly_while_saving_state", &test_diff_diffiter__iterate_randomly_while_saving_state },
    { "iterate_and_generate_patch_text", &test_diff_diffiter__iterate_and_generate_patch_text },
    { "checks_options_version", &test_diff_diffiter__checks_options_version }
};
static const struct clar_func _clar_cb_config_new[] = {
    { "write_new_config", &test_config_new__write_new_config }
};
static const struct clar_func _clar_cb_object_raw_chars[] = {
    { "find_invalid_chars_in_oid", &test_object_raw_chars__find_invalid_chars_in_oid },
    { "build_valid_oid_from_raw_bytes", &test_object_raw_chars__build_valid_oid_from_raw_bytes }
};
static const struct clar_func _clar_cb_repo_init[] = {
    { "standard_repo", &test_repo_init__standard_repo },
    { "standard_repo_noslash", &test_repo_init__standard_repo_noslash },
    { "bare_repo", &test_repo_init__bare_repo },
    { "bare_repo_noslash", &test_repo_init__bare_repo_noslash },
    { "bare_repo_escaping_current_workdir", &test_repo_init__bare_repo_escaping_current_workdir },
    { "reinit_bare_repo", &test_repo_init__reinit_bare_repo },
    { "reinit_too_recent_bare_repo", &test_repo_init__reinit_too_recent_bare_repo },
    { "additional_templates", &test_repo_init__additional_templates },
    { "detect_filemode", &test_repo_init__detect_filemode },
    { "detect_ignorecase", &test_repo_init__detect_ignorecase },
    { "detect_precompose_unicode_required", &test_repo_init__detect_precompose_unicode_required },
    { "reinit_doesnot_overwrite_ignorecase", &test_repo_init__reinit_doesnot_overwrite_ignorecase },
    { "reinit_overwrites_filemode", &test_repo_init__reinit_overwrites_filemode },
    { "sets_logAllRefUpdates_according_to_type_of_repository", &test_repo_init__sets_logAllRefUpdates_according_to_type_of_repository },
    { "extended_0", &test_repo_init__extended_0 },
    { "extended_1", &test_repo_init__extended_1 },
    { "extended_with_template", &test_repo_init__extended_with_template },
    { "extended_with_template_and_shared_mode", &test_repo_init__extended_with_template_and_shared_mode },
    { "can_reinit_an_initialized_repository", &test_repo_init__can_reinit_an_initialized_repository },
    { "init_with_initial_commit", &test_repo_init__init_with_initial_commit }
};
static const struct clar_func _clar_cb_buf_basic[] = {
    { "resize", &test_buf_basic__resize },
    { "printf", &test_buf_basic__printf }
};
static const struct clar_func _clar_cb_object_tree_duplicateentries[] = {
    { "cannot_create_a_duplicate_entry_through_the_treebuilder", &test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_through_the_treebuilder },
    { "cannot_create_a_duplicate_entry_building_a_tree_from_a_index_with_conflicts", &test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_building_a_tree_from_a_index_with_conflicts }
};
static const struct clar_func _clar_cb_stash_submodules[] = {
    { "does_not_stash_modified_submodules", &test_stash_submodules__does_not_stash_modified_submodules },
    { "stash_is_empty_with_modified_submodules", &test_stash_submodules__stash_is_empty_with_modified_submodules }
};
static const struct clar_func _clar_cb_stress_diff[] = {
    { "rename_big_files", &test_stress_diff__rename_big_files },
    { "rename_many_files", &test_stress_diff__rename_many_files }
};
static const struct clar_func _clar_cb_fetchhead_nonetwork[] = {
    { "write", &test_fetchhead_nonetwork__write },
    { "read", &test_fetchhead_nonetwork__read },
    { "read_old_style", &test_fetchhead_nonetwork__read_old_style },
    { "type_missing", &test_fetchhead_nonetwork__type_missing },
    { "name_missing", &test_fetchhead_nonetwork__name_missing },
    { "nonexistent", &test_fetchhead_nonetwork__nonexistent },
    { "invalid_unterminated_last_line", &test_fetchhead_nonetwork__invalid_unterminated_last_line },
    { "invalid_oid", &test_fetchhead_nonetwork__invalid_oid },
    { "invalid_for_merge", &test_fetchhead_nonetwork__invalid_for_merge },
    { "invalid_description", &test_fetchhead_nonetwork__invalid_description }
};
static const struct clar_func _clar_cb_diff_workdir[] = {
    { "to_index", &test_diff_workdir__to_index },
    { "to_index_with_assume_unchanged", &test_diff_workdir__to_index_with_assume_unchanged },
    { "to_tree", &test_diff_workdir__to_tree },
    { "to_index_with_pathspec", &test_diff_workdir__to_index_with_pathspec },
    { "filemode_changes", &test_diff_workdir__filemode_changes },
    { "filemode_changes_with_filemode_false", &test_diff_workdir__filemode_changes_with_filemode_false },
    { "head_index_and_workdir_all_differ", &test_diff_workdir__head_index_and_workdir_all_differ },
    { "eof_newline_changes", &test_diff_workdir__eof_newline_changes },
    { "larger_hunks", &test_diff_workdir__larger_hunks },
    { "submodules", &test_diff_workdir__submodules },
    { "cannot_diff_against_a_bare_repository", &test_diff_workdir__cannot_diff_against_a_bare_repository },
    { "to_null_tree", &test_diff_workdir__to_null_tree },
    { "checks_options_version", &test_diff_workdir__checks_options_version },
    { "can_diff_empty_file", &test_diff_workdir__can_diff_empty_file },
    { "to_index_issue_1397", &test_diff_workdir__to_index_issue_1397 },
    { "to_tree_issue_1397", &test_diff_workdir__to_tree_issue_1397 },
    { "untracked_directory_scenarios", &test_diff_workdir__untracked_directory_scenarios },
    { "untracked_directory_comes_last", &test_diff_workdir__untracked_directory_comes_last },
    { "untracked_with_bom", &test_diff_workdir__untracked_with_bom },
    { "patience_diff", &test_diff_workdir__patience_diff },
    { "with_stale_index", &test_diff_workdir__with_stale_index }
};
static const struct clar_func _clar_cb_filter_ident[] = {
    { "to_worktree", &test_filter_ident__to_worktree },
    { "to_odb", &test_filter_ident__to_odb }
};
static const struct clar_func _clar_cb_refs_branches_ishead[] = {
    { "can_tell_if_a_branch_is_pointed_at_by_HEAD", &test_refs_branches_ishead__can_tell_if_a_branch_is_pointed_at_by_HEAD },
    { "can_properly_handle_unborn_HEAD", &test_refs_branches_ishead__can_properly_handle_unborn_HEAD },
    { "can_properly_handle_missing_HEAD", &test_refs_branches_ishead__can_properly_handle_missing_HEAD },
    { "can_tell_if_a_branch_is_not_pointed_at_by_HEAD", &test_refs_branches_ishead__can_tell_if_a_branch_is_not_pointed_at_by_HEAD },
    { "wont_be_fooled_by_a_non_branch", &test_refs_branches_ishead__wont_be_fooled_by_a_non_branch },
    { "only_direct_references_are_considered", &test_refs_branches_ishead__only_direct_references_are_considered }
};
static const struct clar_func _clar_cb_refs_list[] = {
    { "all", &test_refs_list__all },
    { "do_not_retrieve_references_which_name_end_with_a_lock_extension", &test_refs_list__do_not_retrieve_references_which_name_end_with_a_lock_extension }
};
static const struct clar_func _clar_cb_object_blob_fromchunks[] = {
    { "can_create_a_blob_from_a_in_memory_chunk_provider", &test_object_blob_fromchunks__can_create_a_blob_from_a_in_memory_chunk_provider },
    { "doesnot_overwrite_an_already_existing_object", &test_object_blob_fromchunks__doesnot_overwrite_an_already_existing_object },
    { "creating_a_blob_from_chunks_honors_the_attributes_directives", &test_object_blob_fromchunks__creating_a_blob_from_chunks_honors_the_attributes_directives }
};
static const struct clar_func _clar_cb_object_cache[] = {
    { "cache_everything", &test_object_cache__cache_everything },
    { "cache_no_blobs", &test_object_cache__cache_no_blobs },
    { "threadmania", &test_object_cache__threadmania },
    { "fast_thread_rush", &test_object_cache__fast_thread_rush }
};
static const struct clar_func _clar_cb_filter_blob[] = {
    { "all_crlf", &test_filter_blob__all_crlf },
    { "ident", &test_filter_blob__ident }
};
static const struct clar_func _clar_cb_refs_reflog_reflog[] = {
    { "append_then_read", &test_refs_reflog_reflog__append_then_read },
    { "append_to_then_read", &test_refs_reflog_reflog__append_to_then_read },
    { "renaming_the_reference_moves_the_reflog", &test_refs_reflog_reflog__renaming_the_reference_moves_the_reflog },
    { "reference_has_reflog", &test_refs_reflog_reflog__reference_has_reflog },
    { "reading_the_reflog_from_a_reference_with_no_log_returns_an_empty_one", &test_refs_reflog_reflog__reading_the_reflog_from_a_reference_with_no_log_returns_an_empty_one },
    { "cannot_write_a_moved_reflog", &test_refs_reflog_reflog__cannot_write_a_moved_reflog },
    { "renaming_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_reflog_reflog__renaming_with_an_invalid_name_returns_EINVALIDSPEC }
};
static const struct clar_func _clar_cb_core_bitvec[] = {
    { "0", &test_core_bitvec__0 }
};
static const struct clar_func _clar_cb_submodule_lookup[] = {
    { "simple_lookup", &test_submodule_lookup__simple_lookup },
    { "accessors", &test_submodule_lookup__accessors },
    { "foreach", &test_submodule_lookup__foreach },
    { "lookup_even_with_unborn_head", &test_submodule_lookup__lookup_even_with_unborn_head },
    { "lookup_even_with_missing_index", &test_submodule_lookup__lookup_even_with_missing_index }
};
static const struct clar_func _clar_cb_diff_notify[] = {
    { "notify_single_pathspec", &test_diff_notify__notify_single_pathspec },
    { "notify_multiple_pathspec", &test_diff_notify__notify_multiple_pathspec },
    { "notify_catchall_with_empty_pathspecs", &test_diff_notify__notify_catchall_with_empty_pathspecs },
    { "notify_catchall", &test_diff_notify__notify_catchall },
    { "notify_cb_can_abort_diff", &test_diff_notify__notify_cb_can_abort_diff },
    { "notify_cb_can_be_used_as_filtering_function", &test_diff_notify__notify_cb_can_be_used_as_filtering_function }
};
static const struct clar_func _clar_cb_config_configlevel[] = {
    { "adding_the_same_level_twice_returns_EEXISTS", &test_config_configlevel__adding_the_same_level_twice_returns_EEXISTS },
    { "can_replace_a_config_file_at_an_existing_level", &test_config_configlevel__can_replace_a_config_file_at_an_existing_level },
    { "can_read_from_a_single_level_focused_file_after_parent_config_has_been_freed", &test_config_configlevel__can_read_from_a_single_level_focused_file_after_parent_config_has_been_freed },
    { "fetching_a_level_from_an_empty_compound_config_returns_ENOTFOUND", &test_config_configlevel__fetching_a_level_from_an_empty_compound_config_returns_ENOTFOUND }
};
static const struct clar_func _clar_cb_core_mkdir[] = {
    { "basic", &test_core_mkdir__basic },
    { "with_base", &test_core_mkdir__with_base },
    { "chmods", &test_core_mkdir__chmods }
};
static const struct clar_func _clar_cb_commit_write[] = {
    { "from_memory", &test_commit_write__from_memory },
    { "root", &test_commit_write__root }
};
static const struct clar_func _clar_cb_checkout_conflict[] = {
    { "ignored", &test_checkout_conflict__ignored },
    { "ours", &test_checkout_conflict__ours },
    { "theirs", &test_checkout_conflict__theirs },
    { "diff3", &test_checkout_conflict__diff3 },
    { "automerge", &test_checkout_conflict__automerge },
    { "directory_file", &test_checkout_conflict__directory_file },
    { "directory_file_with_custom_labels", &test_checkout_conflict__directory_file_with_custom_labels },
    { "link_file", &test_checkout_conflict__link_file },
    { "links", &test_checkout_conflict__links },
    { "add_add", &test_checkout_conflict__add_add },
    { "mode_change", &test_checkout_conflict__mode_change },
    { "renames", &test_checkout_conflict__renames },
    { "rename_keep_ours", &test_checkout_conflict__rename_keep_ours },
    { "name_mangled_file_exists_in_workdir", &test_checkout_conflict__name_mangled_file_exists_in_workdir },
    { "update_only", &test_checkout_conflict__update_only },
    { "path_filters", &test_checkout_conflict__path_filters },
    { "report_progress", &test_checkout_conflict__report_progress }
};
static const struct clar_func _clar_cb_diff_tree[] = {
    { "0", &test_diff_tree__0 },
    { "options", &test_diff_tree__options },
    { "bare", &test_diff_tree__bare },
    { "merge", &test_diff_tree__merge },
    { "larger_hunks", &test_diff_tree__larger_hunks },
    { "checks_options_version", &test_diff_tree__checks_options_version },
    { "symlink_blob_mode_changed_to_regular_file", &test_diff_tree__symlink_blob_mode_changed_to_regular_file },
    { "symlink_blob_mode_changed_to_regular_file_as_typechange", &test_diff_tree__symlink_blob_mode_changed_to_regular_file_as_typechange },
    { "regular_blob_mode_changed_to_executable_file", &test_diff_tree__regular_blob_mode_changed_to_executable_file },
    { "issue_1397", &test_diff_tree__issue_1397 },
    { "diff_configs", &test_diff_tree__diff_configs }
};
static const struct clar_func _clar_cb_repo_message[] = {
    { "none", &test_repo_message__none },
    { "message", &test_repo_message__message }
};
static const struct clar_func _clar_cb_pack_indexer[] = {
    { "out_of_order", &test_pack_indexer__out_of_order },
    { "fix_thin", &test_pack_indexer__fix_thin }
};
static const struct clar_func _clar_cb_object_raw_compare[] = {
    { "succeed_on_copy_oid", &test_object_raw_compare__succeed_on_copy_oid },
    { "succeed_on_oid_comparison_lesser", &test_object_raw_compare__succeed_on_oid_comparison_lesser },
    { "succeed_on_oid_comparison_equal", &test_object_raw_compare__succeed_on_oid_comparison_equal },
    { "succeed_on_oid_comparison_greater", &test_object_raw_compare__succeed_on_oid_comparison_greater },
    { "compare_fmt_oids", &test_object_raw_compare__compare_fmt_oids },
    { "compare_allocfmt_oids", &test_object_raw_compare__compare_allocfmt_oids },
    { "compare_pathfmt_oids", &test_object_raw_compare__compare_pathfmt_oids }
};
static const struct clar_func _clar_cb_network_remote_rename[] = {
    { "renaming_a_remote_moves_related_configuration_section", &test_network_remote_rename__renaming_a_remote_moves_related_configuration_section },
    { "renaming_a_remote_updates_branch_related_configuration_entries", &test_network_remote_rename__renaming_a_remote_updates_branch_related_configuration_entries },
    { "renaming_a_remote_updates_default_fetchrefspec", &test_network_remote_rename__renaming_a_remote_updates_default_fetchrefspec },
    { "renaming_a_remote_without_a_fetchrefspec_doesnt_create_one", &test_network_remote_rename__renaming_a_remote_without_a_fetchrefspec_doesnt_create_one },
    { "renaming_a_remote_notifies_of_non_default_fetchrefspec", &test_network_remote_rename__renaming_a_remote_notifies_of_non_default_fetchrefspec },
    { "new_name_can_contain_dots", &test_network_remote_rename__new_name_can_contain_dots },
    { "new_name_must_conform_to_reference_naming_conventions", &test_network_remote_rename__new_name_must_conform_to_reference_naming_conventions },
    { "renamed_name_is_persisted", &test_network_remote_rename__renamed_name_is_persisted },
    { "cannot_overwrite_an_existing_remote", &test_network_remote_rename__cannot_overwrite_an_existing_remote },
    { "renaming_a_remote_moves_the_underlying_reference", &test_network_remote_rename__renaming_a_remote_moves_the_underlying_reference },
    { "cannot_rename_an_inmemory_remote", &test_network_remote_rename__cannot_rename_an_inmemory_remote }
};
static const struct clar_func _clar_cb_object_commit_commitstagedfile[] = {
    { "generate_predictable_object_ids", &test_object_commit_commitstagedfile__generate_predictable_object_ids }
};
static const struct clar_func _clar_cb_commit_parse[] = {
    { "header", &test_commit_parse__header },
    { "signature", &test_commit_parse__signature },
    { "entire_commit", &test_commit_parse__entire_commit },
    { "details0", &test_commit_parse__details0 },
    { "leading_lf", &test_commit_parse__leading_lf },
    { "only_lf", &test_commit_parse__only_lf }
};
static const struct clar_func _clar_cb_diff_blob[] = {
    { "can_compare_text_blobs", &test_diff_blob__can_compare_text_blobs },
    { "can_compare_text_blobs_with_patch", &test_diff_blob__can_compare_text_blobs_with_patch },
    { "can_compare_against_null_blobs", &test_diff_blob__can_compare_against_null_blobs },
    { "can_compare_against_null_blobs_with_patch", &test_diff_blob__can_compare_against_null_blobs_with_patch },
    { "can_compare_identical_blobs", &test_diff_blob__can_compare_identical_blobs },
    { "can_compare_identical_blobs_with_patch", &test_diff_blob__can_compare_identical_blobs_with_patch },
    { "can_compare_two_binary_blobs", &test_diff_blob__can_compare_two_binary_blobs },
    { "can_compare_a_binary_blob_and_a_text_blob", &test_diff_blob__can_compare_a_binary_blob_and_a_text_blob },
    { "comparing_two_text_blobs_honors_interhunkcontext", &test_diff_blob__comparing_two_text_blobs_honors_interhunkcontext },
    { "checks_options_version_too_low", &test_diff_blob__checks_options_version_too_low },
    { "checks_options_version_too_high", &test_diff_blob__checks_options_version_too_high },
    { "can_correctly_detect_a_binary_blob_as_binary", &test_diff_blob__can_correctly_detect_a_binary_blob_as_binary },
    { "can_correctly_detect_a_textual_blob_as_non_binary", &test_diff_blob__can_correctly_detect_a_textual_blob_as_non_binary },
    { "can_compare_blob_to_buffer", &test_diff_blob__can_compare_blob_to_buffer },
    { "can_compare_blob_to_buffer_with_patch", &test_diff_blob__can_compare_blob_to_buffer_with_patch },
    { "binary_data_comparisons", &test_diff_blob__binary_data_comparisons },
    { "using_path_and_attributes", &test_diff_blob__using_path_and_attributes }
};
static const struct clar_func _clar_cb_refs_read[] = {
    { "loose_tag", &test_refs_read__loose_tag },
    { "nonexisting_tag", &test_refs_read__nonexisting_tag },
    { "symbolic", &test_refs_read__symbolic },
    { "nested_symbolic", &test_refs_read__nested_symbolic },
    { "head_then_master", &test_refs_read__head_then_master },
    { "master_then_head", &test_refs_read__master_then_head },
    { "packed", &test_refs_read__packed },
    { "loose_first", &test_refs_read__loose_first },
    { "chomped", &test_refs_read__chomped },
    { "trailing", &test_refs_read__trailing },
    { "unfound_return_ENOTFOUND", &test_refs_read__unfound_return_ENOTFOUND },
    { "can_determine_if_a_reference_is_a_local_branch", &test_refs_read__can_determine_if_a_reference_is_a_local_branch },
    { "can_determine_if_a_reference_is_a_tag", &test_refs_read__can_determine_if_a_reference_is_a_tag },
    { "invalid_name_returns_EINVALIDSPEC", &test_refs_read__invalid_name_returns_EINVALIDSPEC }
};
static const struct clar_func _clar_cb_threads_refdb[] = {
    { "iterator", &test_threads_refdb__iterator },
    { "edit_while_iterate", &test_threads_refdb__edit_while_iterate }
};
static const struct clar_func _clar_cb_config_validkeyname[] = {
    { "accessing_requires_a_valid_name", &test_config_validkeyname__accessing_requires_a_valid_name },
    { "renaming_a_section_requires_a_valid_name", &test_config_validkeyname__renaming_a_section_requires_a_valid_name }
};
static const struct clar_func _clar_cb_refs_branches_delete[] = {
    { "can_not_delete_a_branch_pointed_at_by_HEAD", &test_refs_branches_delete__can_not_delete_a_branch_pointed_at_by_HEAD },
    { "can_delete_a_branch_even_if_HEAD_is_missing", &test_refs_branches_delete__can_delete_a_branch_even_if_HEAD_is_missing },
    { "can_delete_a_branch_when_HEAD_is_unborn", &test_refs_branches_delete__can_delete_a_branch_when_HEAD_is_unborn },
    { "can_delete_a_branch_pointed_at_by_detached_HEAD", &test_refs_branches_delete__can_delete_a_branch_pointed_at_by_detached_HEAD },
    { "can_delete_a_local_branch", &test_refs_branches_delete__can_delete_a_local_branch },
    { "can_delete_a_remote_branch", &test_refs_branches_delete__can_delete_a_remote_branch },
    { "deleting_a_branch_removes_related_configuration_data", &test_refs_branches_delete__deleting_a_branch_removes_related_configuration_data }
};
static const struct clar_func _clar_cb_date_date[] = {
    { "overflow", &test_date_date__overflow }
};
static const struct clar_func _clar_cb_refs_pack[] = {
    { "empty", &test_refs_pack__empty },
    { "loose", &test_refs_pack__loose },
    { "symbolic", &test_refs_pack__symbolic }
};
static const struct clar_func _clar_cb_refs_overwrite[] = {
    { "symbolic", &test_refs_overwrite__symbolic },
    { "object_id", &test_refs_overwrite__object_id },
    { "object_id_with_symbolic", &test_refs_overwrite__object_id_with_symbolic },
    { "symbolic_with_object_id", &test_refs_overwrite__symbolic_with_object_id }
};
static const struct clar_func _clar_cb_merge_workdir_simple[] = {
    { "automerge", &test_merge_workdir_simple__automerge },
    { "automerge_crlf", &test_merge_workdir_simple__automerge_crlf },
    { "diff3", &test_merge_workdir_simple__diff3 },
    { "checkout_ours", &test_merge_workdir_simple__checkout_ours },
    { "favor_ours", &test_merge_workdir_simple__favor_ours },
    { "favor_theirs", &test_merge_workdir_simple__favor_theirs },
    { "directory_file", &test_merge_workdir_simple__directory_file },
    { "unrelated", &test_merge_workdir_simple__unrelated },
    { "unrelated_with_conflicts", &test_merge_workdir_simple__unrelated_with_conflicts }
};
static const struct clar_func _clar_cb_revwalk_signatureparsing[] = {
    { "do_not_choke_when_name_contains_angle_brackets", &test_revwalk_signatureparsing__do_not_choke_when_name_contains_angle_brackets }
};
static const struct clar_func _clar_cb_core_opts[] = {
    { "readwrite", &test_core_opts__readwrite }
};
static const struct clar_func _clar_cb_object_tag_write[] = {
    { "basic", &test_object_tag_write__basic },
    { "overwrite", &test_object_tag_write__overwrite },
    { "replace", &test_object_tag_write__replace },
    { "lightweight", &test_object_tag_write__lightweight },
    { "lightweight_over_existing", &test_object_tag_write__lightweight_over_existing },
    { "delete", &test_object_tag_write__delete },
    { "creating_with_an_invalid_name_returns_EINVALIDSPEC", &test_object_tag_write__creating_with_an_invalid_name_returns_EINVALIDSPEC },
    { "deleting_with_an_invalid_name_returns_EINVALIDSPEC", &test_object_tag_write__deleting_with_an_invalid_name_returns_EINVALIDSPEC },
    { "creating_an_annotation_stores_the_new_object_in_the_odb", &test_object_tag_write__creating_an_annotation_stores_the_new_object_in_the_odb },
    { "creating_an_annotation_does_not_create_a_reference", &test_object_tag_write__creating_an_annotation_does_not_create_a_reference }
};
static const struct clar_func _clar_cb_config_backend[] = {
    { "checks_version", &test_config_backend__checks_version }
};
static const struct clar_func _clar_cb_refs_branches_upstreamname[] = {
    { "can_retrieve_the_remote_tracking_reference_name_of_a_local_branch", &test_refs_branches_upstreamname__can_retrieve_the_remote_tracking_reference_name_of_a_local_branch },
    { "can_retrieve_the_local_upstream_reference_name_of_a_local_branch", &test_refs_branches_upstreamname__can_retrieve_the_local_upstream_reference_name_of_a_local_branch },
    { "can_return_the_size_of_thelocal_upstream_reference_name_of_a_local_branch", &test_refs_branches_upstreamname__can_return_the_size_of_thelocal_upstream_reference_name_of_a_local_branch }
};
static const struct clar_func _clar_cb_network_fetchlocal[] = {
    { "complete", &test_network_fetchlocal__complete },
    { "partial", &test_network_fetchlocal__partial }
};
static const struct clar_func _clar_cb_refs_branches_name[] = {
    { "can_get_local_branch_name", &test_refs_branches_name__can_get_local_branch_name },
    { "can_get_remote_branch_name", &test_refs_branches_name__can_get_remote_branch_name },
    { "error_when_ref_is_no_branch", &test_refs_branches_name__error_when_ref_is_no_branch }
};
static const struct clar_func _clar_cb_odb_streamwrite[] = {
    { "can_accept_chunks", &test_odb_streamwrite__can_accept_chunks },
    { "can_detect_missing_bytes", &test_odb_streamwrite__can_detect_missing_bytes },
    { "can_detect_additional_bytes", &test_odb_streamwrite__can_detect_additional_bytes }
};
static const struct clar_func _clar_cb_odb_foreach[] = {
    { "foreach", &test_odb_foreach__foreach },
    { "one_pack", &test_odb_foreach__one_pack },
    { "interrupt_foreach", &test_odb_foreach__interrupt_foreach }
};
static const struct clar_func _clar_cb_checkout_head[] = {
    { "unborn_head_returns_GIT_EUNBORNBRANCH", &test_checkout_head__unborn_head_returns_GIT_EUNBORNBRANCH },
    { "with_index_only_tree", &test_checkout_head__with_index_only_tree }
};
static const struct clar_func _clar_cb_reset_default[] = {
    { "resetting_filepaths_against_a_null_target_removes_them_from_the_index", &test_reset_default__resetting_filepaths_against_a_null_target_removes_them_from_the_index },
    { "resetting_filepaths_replaces_their_corresponding_index_entries", &test_reset_default__resetting_filepaths_replaces_their_corresponding_index_entries },
    { "resetting_filepaths_clears_previous_conflicts", &test_reset_default__resetting_filepaths_clears_previous_conflicts },
    { "resetting_unknown_filepaths_does_not_fail", &test_reset_default__resetting_unknown_filepaths_does_not_fail }
};
static const struct clar_func _clar_cb_refs_branches_upstream[] = {
    { "can_retrieve_the_remote_tracking_reference_of_a_local_branch", &test_refs_branches_upstream__can_retrieve_the_remote_tracking_reference_of_a_local_branch },
    { "can_retrieve_the_local_upstream_reference_of_a_local_branch", &test_refs_branches_upstream__can_retrieve_the_local_upstream_reference_of_a_local_branch },
    { "cannot_retrieve_a_remote_upstream_reference_from_a_non_branch", &test_refs_branches_upstream__cannot_retrieve_a_remote_upstream_reference_from_a_non_branch },
    { "trying_to_retrieve_a_remote_tracking_reference_from_a_plain_local_branch_returns_GIT_ENOTFOUND", &test_refs_branches_upstream__trying_to_retrieve_a_remote_tracking_reference_from_a_plain_local_branch_returns_GIT_ENOTFOUND },
    { "trying_to_retrieve_a_remote_tracking_reference_from_a_branch_with_no_fetchspec_returns_GIT_ENOTFOUND", &test_refs_branches_upstream__trying_to_retrieve_a_remote_tracking_reference_from_a_branch_with_no_fetchspec_returns_GIT_ENOTFOUND },
    { "retrieve_a_remote_tracking_reference_from_a_branch_with_no_remote_returns_GIT_ENOTFOUND", &test_refs_branches_upstream__retrieve_a_remote_tracking_reference_from_a_branch_with_no_remote_returns_GIT_ENOTFOUND },
    { "set_unset_upstream", &test_refs_branches_upstream__set_unset_upstream }
};
static const struct clar_func _clar_cb_odb_mixed[] = {
    { "dup_oid", &test_odb_mixed__dup_oid },
    { "dup_oid_prefix_0", &test_odb_mixed__dup_oid_prefix_0 }
};
static const struct clar_func _clar_cb_merge_workdir_fastforward[] = {
    { "fastforward", &test_merge_workdir_fastforward__fastforward },
    { "fastforward_only", &test_merge_workdir_fastforward__fastforward_only },
    { "no_fastforward", &test_merge_workdir_fastforward__no_fastforward },
    { "uptodate", &test_merge_workdir_fastforward__uptodate },
    { "uptodate_merging_prev_commit", &test_merge_workdir_fastforward__uptodate_merging_prev_commit }
};
static const struct clar_func _clar_cb_diff_iterator[] = {
    { "tree_0", &test_diff_iterator__tree_0 },
    { "tree_1", &test_diff_iterator__tree_1 },
    { "tree_2", &test_diff_iterator__tree_2 },
    { "tree_3", &test_diff_iterator__tree_3 },
    { "tree_4", &test_diff_iterator__tree_4 },
    { "tree_4_ranged", &test_diff_iterator__tree_4_ranged },
    { "tree_ranged_0", &test_diff_iterator__tree_ranged_0 },
    { "tree_ranged_1", &test_diff_iterator__tree_ranged_1 },
    { "tree_range_empty_0", &test_diff_iterator__tree_range_empty_0 },
    { "tree_range_empty_1", &test_diff_iterator__tree_range_empty_1 },
    { "tree_range_empty_2", &test_diff_iterator__tree_range_empty_2 },
    { "tree_special_functions", &test_diff_iterator__tree_special_functions },
    { "index_0", &test_diff_iterator__index_0 },
    { "index_range", &test_diff_iterator__index_range },
    { "index_range_empty_0", &test_diff_iterator__index_range_empty_0 },
    { "index_range_empty_1", &test_diff_iterator__index_range_empty_1 },
    { "index_range_empty_2", &test_diff_iterator__index_range_empty_2 },
    { "index_1", &test_diff_iterator__index_1 },
    { "workdir_0", &test_diff_iterator__workdir_0 },
    { "workdir_1", &test_diff_iterator__workdir_1 },
    { "workdir_1_ranged_0", &test_diff_iterator__workdir_1_ranged_0 },
    { "workdir_1_ranged_1", &test_diff_iterator__workdir_1_ranged_1 },
    { "workdir_1_ranged_3", &test_diff_iterator__workdir_1_ranged_3 },
    { "workdir_1_ranged_4", &test_diff_iterator__workdir_1_ranged_4 },
    { "workdir_1_ranged_5", &test_diff_iterator__workdir_1_ranged_5 },
    { "workdir_1_ranged_empty_0", &test_diff_iterator__workdir_1_ranged_empty_0 },
    { "workdir_1_ranged_empty_1", &test_diff_iterator__workdir_1_ranged_empty_1 },
    { "workdir_1_ranged_empty_2", &test_diff_iterator__workdir_1_ranged_empty_2 },
    { "workdir_builtin_ignores", &test_diff_iterator__workdir_builtin_ignores },
    { "workdir_handles_icase_range", &test_diff_iterator__workdir_handles_icase_range },
    { "tree_handles_icase_range", &test_diff_iterator__tree_handles_icase_range },
    { "index_handles_icase_range", &test_diff_iterator__index_handles_icase_range }
};
static const struct clar_func _clar_cb_merge_trees_trivial[] = {
    { "2alt", &test_merge_trees_trivial__2alt },
    { "3alt", &test_merge_trees_trivial__3alt },
    { "4", &test_merge_trees_trivial__4 },
    { "5alt_1", &test_merge_trees_trivial__5alt_1 },
    { "5alt_2", &test_merge_trees_trivial__5alt_2 },
    { "6", &test_merge_trees_trivial__6 },
    { "6_automerge", &test_merge_trees_trivial__6_automerge },
    { "8", &test_merge_trees_trivial__8 },
    { "8_automerge", &test_merge_trees_trivial__8_automerge },
    { "7", &test_merge_trees_trivial__7 },
    { "7_automerge", &test_merge_trees_trivial__7_automerge },
    { "10", &test_merge_trees_trivial__10 },
    { "10_automerge", &test_merge_trees_trivial__10_automerge },
    { "9", &test_merge_trees_trivial__9 },
    { "9_automerge", &test_merge_trees_trivial__9_automerge },
    { "13", &test_merge_trees_trivial__13 },
    { "14", &test_merge_trees_trivial__14 },
    { "11", &test_merge_trees_trivial__11 }
};
static const struct clar_func _clar_cb_core_dirent[] = {
    { "dont_traverse_dot", &test_core_dirent__dont_traverse_dot },
    { "traverse_subfolder", &test_core_dirent__traverse_subfolder },
    { "traverse_slash_terminated_folder", &test_core_dirent__traverse_slash_terminated_folder },
    { "dont_traverse_empty_folders", &test_core_dirent__dont_traverse_empty_folders },
    { "traverse_weird_filenames", &test_core_dirent__traverse_weird_filenames },
    { "length_limits", &test_core_dirent__length_limits },
    { "empty_dir", &test_core_dirent__empty_dir }
};
static const struct clar_func _clar_cb_index_addall[] = {
    { "repo_lifecycle", &test_index_addall__repo_lifecycle }
};
static const struct clar_func _clar_cb_refs_shorthand[] = {
    { "0", &test_refs_shorthand__0 }
};
static const struct clar_func _clar_cb_index_read_tree[] = {
    { "read_write_involution", &test_index_read_tree__read_write_involution }
};
static const struct clar_func _clar_cb_clone_nonetwork[] = {
    { "bad_urls", &test_clone_nonetwork__bad_urls },
    { "do_not_clean_existing_directory", &test_clone_nonetwork__do_not_clean_existing_directory },
    { "local", &test_clone_nonetwork__local },
    { "local_absolute_path", &test_clone_nonetwork__local_absolute_path },
    { "local_bare", &test_clone_nonetwork__local_bare },
    { "fail_when_the_target_is_a_file", &test_clone_nonetwork__fail_when_the_target_is_a_file },
    { "fail_with_already_existing_but_non_empty_directory", &test_clone_nonetwork__fail_with_already_existing_but_non_empty_directory },
    { "custom_origin_name", &test_clone_nonetwork__custom_origin_name },
    { "defaults", &test_clone_nonetwork__defaults },
    { "cope_with_already_existing_directory", &test_clone_nonetwork__cope_with_already_existing_directory },
    { "can_prevent_the_checkout_of_a_standard_repo", &test_clone_nonetwork__can_prevent_the_checkout_of_a_standard_repo },
    { "can_checkout_given_branch", &test_clone_nonetwork__can_checkout_given_branch },
    { "can_detached_head", &test_clone_nonetwork__can_detached_head }
};
static const struct clar_func _clar_cb_index_tests[] = {
    { "empty_index", &test_index_tests__empty_index },
    { "default_test_index", &test_index_tests__default_test_index },
    { "gitgit_index", &test_index_tests__gitgit_index },
    { "find_in_existing", &test_index_tests__find_in_existing },
    { "find_in_empty", &test_index_tests__find_in_empty },
    { "write", &test_index_tests__write },
    { "sort0", &test_index_tests__sort0 },
    { "sort1", &test_index_tests__sort1 },
    { "add", &test_index_tests__add },
    { "add_issue_1397", &test_index_tests__add_issue_1397 },
    { "add_bypath_to_a_bare_repository_returns_EBAREPO", &test_index_tests__add_bypath_to_a_bare_repository_returns_EBAREPO },
    { "write_invalid_filename", &test_index_tests__write_invalid_filename },
    { "remove_entry", &test_index_tests__remove_entry },
    { "remove_directory", &test_index_tests__remove_directory },
    { "preserves_case", &test_index_tests__preserves_case },
    { "elocked", &test_index_tests__elocked },
    { "reload_from_disk", &test_index_tests__reload_from_disk },
    { "corrupted_extension", &test_index_tests__corrupted_extension }
};
static const struct clar_func _clar_cb_commit_commit[] = {
    { "create_unexisting_update_ref", &test_commit_commit__create_unexisting_update_ref }
};
static const struct clar_func _clar_cb_blame_getters[] = {
    { "byindex", &test_blame_getters__byindex },
    { "byline", &test_blame_getters__byline }
};
static const struct clar_func _clar_cb_repo_config[] = {
    { "open_missing_global", &test_repo_config__open_missing_global },
    { "open_missing_global_with_separators", &test_repo_config__open_missing_global_with_separators },
    { "read_no_configs", &test_repo_config__read_no_configs }
};
static const struct clar_func _clar_cb_odb_packed_one[] = {
    { "mass_read", &test_odb_packed_one__mass_read },
    { "read_header_0", &test_odb_packed_one__read_header_0 }
};
static const struct clar_func _clar_cb_object_tag_read[] = {
    { "parse", &test_object_tag_read__parse },
    { "parse_without_tagger", &test_object_tag_read__parse_without_tagger },
    { "parse_without_message", &test_object_tag_read__parse_without_message },
    { "without_tagger_nor_message", &test_object_tag_read__without_tagger_nor_message }
};
static const struct clar_func _clar_cb_status_submodules[] = {
    { "api", &test_status_submodules__api },
    { "0", &test_status_submodules__0 },
    { "1", &test_status_submodules__1 },
    { "single_file", &test_status_submodules__single_file },
    { "moved_head", &test_status_submodules__moved_head },
    { "dirty_workdir_only", &test_status_submodules__dirty_workdir_only }
};
static const struct clar_func _clar_cb_core_oid[] = {
    { "streq", &test_core_oid__streq },
    { "strcmp", &test_core_oid__strcmp },
    { "ncmp", &test_core_oid__ncmp }
};
static const struct clar_func _clar_cb_index_inmemory[] = {
    { "can_create_an_inmemory_index", &test_index_inmemory__can_create_an_inmemory_index },
    { "cannot_add_bypath_to_an_inmemory_index", &test_index_inmemory__cannot_add_bypath_to_an_inmemory_index }
};
static const struct clar_func _clar_cb_refs_branches_move[] = {
    { "can_move_a_local_branch", &test_refs_branches_move__can_move_a_local_branch },
    { "can_move_a_local_branch_to_a_different_namespace", &test_refs_branches_move__can_move_a_local_branch_to_a_different_namespace },
    { "can_move_a_local_branch_to_a_partially_colliding_namespace", &test_refs_branches_move__can_move_a_local_branch_to_a_partially_colliding_namespace },
    { "can_not_move_a_branch_if_its_destination_name_collide_with_an_existing_one", &test_refs_branches_move__can_not_move_a_branch_if_its_destination_name_collide_with_an_existing_one },
    { "moving_a_branch_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_branches_move__moving_a_branch_with_an_invalid_name_returns_EINVALIDSPEC },
    { "can_not_move_a_non_branch", &test_refs_branches_move__can_not_move_a_non_branch },
    { "can_force_move_over_an_existing_branch", &test_refs_branches_move__can_force_move_over_an_existing_branch },
    { "moving_a_branch_moves_related_configuration_data", &test_refs_branches_move__moving_a_branch_moves_related_configuration_data },
    { "moving_the_branch_pointed_at_by_HEAD_updates_HEAD", &test_refs_branches_move__moving_the_branch_pointed_at_by_HEAD_updates_HEAD }
};
static const struct clar_func _clar_cb_notes_notesref[] = {
    { "config_corenotesref", &test_notes_notesref__config_corenotesref }
};
static const struct clar_func _clar_cb_core_errors[] = {
    { "public_api", &test_core_errors__public_api },
    { "new_school", &test_core_errors__new_school }
};
static const struct clar_func _clar_cb_network_remote_isvalidname[] = {
    { "can_detect_invalid_formats", &test_network_remote_isvalidname__can_detect_invalid_formats },
    { "wont_hopefully_choke_on_valid_formats", &test_network_remote_isvalidname__wont_hopefully_choke_on_valid_formats }
};
static const struct clar_func _clar_cb_repo_state[] = {
    { "none_with_HEAD_attached", &test_repo_state__none_with_HEAD_attached },
    { "none_with_HEAD_detached", &test_repo_state__none_with_HEAD_detached },
    { "merge", &test_repo_state__merge },
    { "revert", &test_repo_state__revert },
    { "cherry_pick", &test_repo_state__cherry_pick },
    { "bisect", &test_repo_state__bisect },
    { "rebase_interactive", &test_repo_state__rebase_interactive },
    { "rebase_merge", &test_repo_state__rebase_merge },
    { "rebase", &test_repo_state__rebase },
    { "apply_mailbox", &test_repo_state__apply_mailbox },
    { "apply_mailbox_or_rebase", &test_repo_state__apply_mailbox_or_rebase }
};
static const struct clar_func _clar_cb_blame_harder[] = {
    { "m", &test_blame_harder__m },
    { "c", &test_blame_harder__c },
    { "cc", &test_blame_harder__cc },
    { "ccc", &test_blame_harder__ccc }
};
static const struct clar_func _clar_cb_stash_save[] = {
    { "does_not_keep_index_by_default", &test_stash_save__does_not_keep_index_by_default },
    { "can_keep_index", &test_stash_save__can_keep_index },
    { "can_include_untracked_files", &test_stash_save__can_include_untracked_files },
    { "can_include_untracked_and_ignored_files", &test_stash_save__can_include_untracked_and_ignored_files },
    { "can_accept_a_message", &test_stash_save__can_accept_a_message },
    { "cannot_stash_against_an_unborn_branch", &test_stash_save__cannot_stash_against_an_unborn_branch },
    { "cannot_stash_against_a_bare_repository", &test_stash_save__cannot_stash_against_a_bare_repository },
    { "can_stash_against_a_detached_head", &test_stash_save__can_stash_against_a_detached_head },
    { "stashing_updates_the_reflog", &test_stash_save__stashing_updates_the_reflog },
    { "cannot_stash_when_there_are_no_local_change", &test_stash_save__cannot_stash_when_there_are_no_local_change },
    { "can_stage_normal_then_stage_untracked", &test_stash_save__can_stage_normal_then_stage_untracked },
    { "including_untracked_without_any_untracked_file_creates_an_empty_tree", &test_stash_save__including_untracked_without_any_untracked_file_creates_an_empty_tree }
};
static const struct clar_func _clar_cb_repo_discover[] = {
    { "0", &test_repo_discover__0 }
};
static const struct clar_func _clar_cb_refs_update[] = {
    { "updating_the_target_of_a_symref_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_update__updating_the_target_of_a_symref_with_an_invalid_name_returns_EINVALIDSPEC }
};
static const struct clar_func _clar_cb_status_ignore[] = {
    { "0", &test_status_ignore__0 },
    { "1", &test_status_ignore__1 },
    { "empty_repo_with_gitignore_rewrite", &test_status_ignore__empty_repo_with_gitignore_rewrite },
    { "ignore_pattern_contains_space", &test_status_ignore__ignore_pattern_contains_space },
    { "ignore_pattern_ignorecase", &test_status_ignore__ignore_pattern_ignorecase },
    { "subdirectories", &test_status_ignore__subdirectories },
    { "subdirectories_recursion", &test_status_ignore__subdirectories_recursion },
    { "adding_internal_ignores", &test_status_ignore__adding_internal_ignores },
    { "add_internal_as_first_thing", &test_status_ignore__add_internal_as_first_thing },
    { "internal_ignores_inside_deep_paths", &test_status_ignore__internal_ignores_inside_deep_paths },
    { "automatically_ignore_bad_files", &test_status_ignore__automatically_ignore_bad_files },
    { "filenames_with_special_prefixes_do_not_interfere_with_status_retrieval", &test_status_ignore__filenames_with_special_prefixes_do_not_interfere_with_status_retrieval },
    { "issue_1766_negated_ignores", &test_status_ignore__issue_1766_negated_ignores }
};
static const struct clar_func _clar_cb_attr_file[] = {
    { "simple_read", &test_attr_file__simple_read },
    { "match_variants", &test_attr_file__match_variants },
    { "assign_variants", &test_attr_file__assign_variants },
    { "check_attr_examples", &test_attr_file__check_attr_examples }
};
static const struct clar_func _clar_cb_core_buffer[] = {
    { "0", &test_core_buffer__0 },
    { "1", &test_core_buffer__1 },
    { "2", &test_core_buffer__2 },
    { "3", &test_core_buffer__3 },
    { "4", &test_core_buffer__4 },
    { "5", &test_core_buffer__5 },
    { "6", &test_core_buffer__6 },
    { "7", &test_core_buffer__7 },
    { "8", &test_core_buffer__8 },
    { "9", &test_core_buffer__9 },
    { "10", &test_core_buffer__10 },
    { "11", &test_core_buffer__11 },
    { "rfind_variants", &test_core_buffer__rfind_variants },
    { "puts_escaped", &test_core_buffer__puts_escaped },
    { "unescape", &test_core_buffer__unescape },
    { "base64", &test_core_buffer__base64 },
    { "classify_with_utf8", &test_core_buffer__classify_with_utf8 },
    { "similarity_metric", &test_core_buffer__similarity_metric },
    { "similarity_metric_whitespace", &test_core_buffer__similarity_metric_whitespace },
    { "lf_and_crlf_conversions", &test_core_buffer__lf_and_crlf_conversions }
};
static const struct clar_func _clar_cb_checkout_tree[] = {
    { "cannot_checkout_a_non_treeish", &test_checkout_tree__cannot_checkout_a_non_treeish },
    { "can_checkout_a_subdirectory_from_a_commit", &test_checkout_tree__can_checkout_a_subdirectory_from_a_commit },
    { "can_checkout_and_remove_directory", &test_checkout_tree__can_checkout_and_remove_directory },
    { "can_checkout_a_subdirectory_from_a_subtree", &test_checkout_tree__can_checkout_a_subdirectory_from_a_subtree },
    { "calls_progress_callback", &test_checkout_tree__calls_progress_callback },
    { "doesnt_write_unrequested_files_to_worktree", &test_checkout_tree__doesnt_write_unrequested_files_to_worktree },
    { "can_switch_branches", &test_checkout_tree__can_switch_branches },
    { "can_remove_untracked", &test_checkout_tree__can_remove_untracked },
    { "can_remove_ignored", &test_checkout_tree__can_remove_ignored },
    { "can_update_only", &test_checkout_tree__can_update_only },
    { "can_checkout_with_pattern", &test_checkout_tree__can_checkout_with_pattern },
    { "can_disable_pattern_match", &test_checkout_tree__can_disable_pattern_match },
    { "checking_out_a_conflicting_type_change_returns_EMERGECONFLICT", &test_checkout_tree__checking_out_a_conflicting_type_change_returns_EMERGECONFLICT },
    { "checking_out_a_conflicting_type_change_returns_EMERGECONFLICT_2", &test_checkout_tree__checking_out_a_conflicting_type_change_returns_EMERGECONFLICT_2 },
    { "checking_out_a_conflicting_content_change_returns_EMERGECONFLICT", &test_checkout_tree__checking_out_a_conflicting_content_change_returns_EMERGECONFLICT },
    { "donot_update_deleted_file_by_default", &test_checkout_tree__donot_update_deleted_file_by_default },
    { "can_checkout_with_last_workdir_item_missing", &test_checkout_tree__can_checkout_with_last_workdir_item_missing },
    { "issue_1397", &test_checkout_tree__issue_1397 },
    { "can_write_to_empty_dirs", &test_checkout_tree__can_write_to_empty_dirs },
    { "fails_when_dir_in_use", &test_checkout_tree__fails_when_dir_in_use },
    { "can_continue_when_dir_in_use", &test_checkout_tree__can_continue_when_dir_in_use },
    { "target_directory_from_bare", &test_checkout_tree__target_directory_from_bare },
    { "extremely_long_file_name", &test_checkout_tree__extremely_long_file_name },
    { "fails_when_conflicts_exist_in_index", &test_checkout_tree__fails_when_conflicts_exist_in_index }
};
static const struct clar_func _clar_cb_index_conflicts[] = {
    { "add", &test_index_conflicts__add },
    { "add_fixes_incorrect_stage", &test_index_conflicts__add_fixes_incorrect_stage },
    { "get", &test_index_conflicts__get },
    { "iterate", &test_index_conflicts__iterate },
    { "remove", &test_index_conflicts__remove },
    { "moved_to_reuc_on_add", &test_index_conflicts__moved_to_reuc_on_add },
    { "moved_to_reuc_on_remove", &test_index_conflicts__moved_to_reuc_on_remove },
    { "remove_all_conflicts", &test_index_conflicts__remove_all_conflicts },
    { "partial", &test_index_conflicts__partial }
};
static const struct clar_func _clar_cb_network_refspecs[] = {
    { "parsing", &test_network_refspecs__parsing }
};
static const struct clar_func _clar_cb_checkout_index[] = {
    { "cannot_checkout_a_bare_repository", &test_checkout_index__cannot_checkout_a_bare_repository },
    { "can_create_missing_files", &test_checkout_index__can_create_missing_files },
    { "can_remove_untracked_files", &test_checkout_index__can_remove_untracked_files },
    { "honor_the_specified_pathspecs", &test_checkout_index__honor_the_specified_pathspecs },
    { "honor_the_gitattributes_directives", &test_checkout_index__honor_the_gitattributes_directives },
    { "honor_coreautocrlf_setting_set_to_true", &test_checkout_index__honor_coreautocrlf_setting_set_to_true },
    { "honor_coresymlinks_setting_set_to_true", &test_checkout_index__honor_coresymlinks_setting_set_to_true },
    { "honor_coresymlinks_setting_set_to_false", &test_checkout_index__honor_coresymlinks_setting_set_to_false },
    { "donot_overwrite_modified_file_by_default", &test_checkout_index__donot_overwrite_modified_file_by_default },
    { "can_overwrite_modified_file", &test_checkout_index__can_overwrite_modified_file },
    { "options_disable_filters", &test_checkout_index__options_disable_filters },
    { "options_dir_modes", &test_checkout_index__options_dir_modes },
    { "options_override_file_modes", &test_checkout_index__options_override_file_modes },
    { "options_open_flags", &test_checkout_index__options_open_flags },
    { "can_notify_of_skipped_files", &test_checkout_index__can_notify_of_skipped_files },
    { "wont_notify_of_expected_line_ending_changes", &test_checkout_index__wont_notify_of_expected_line_ending_changes },
    { "calls_progress_callback", &test_checkout_index__calls_progress_callback },
    { "can_overcome_name_clashes", &test_checkout_index__can_overcome_name_clashes },
    { "validates_struct_version", &test_checkout_index__validates_struct_version },
    { "can_update_prefixed_files", &test_checkout_index__can_update_prefixed_files },
    { "can_checkout_a_newly_initialized_repository", &test_checkout_index__can_checkout_a_newly_initialized_repository },
    { "issue_1397", &test_checkout_index__issue_1397 },
    { "target_directory", &test_checkout_index__target_directory },
    { "target_directory_from_bare", &test_checkout_index__target_directory_from_bare },
    { "can_get_repo_from_index", &test_checkout_index__can_get_repo_from_index }
};
static const struct clar_func _clar_cb_network_remote_local[] = {
    { "connected", &test_network_remote_local__connected },
    { "retrieve_advertised_references", &test_network_remote_local__retrieve_advertised_references },
    { "retrieve_advertised_references_after_disconnect", &test_network_remote_local__retrieve_advertised_references_after_disconnect },
    { "retrieve_advertised_references_from_spaced_repository", &test_network_remote_local__retrieve_advertised_references_from_spaced_repository },
    { "nested_tags_are_completely_peeled", &test_network_remote_local__nested_tags_are_completely_peeled },
    { "shorthand_fetch_refspec0", &test_network_remote_local__shorthand_fetch_refspec0 },
    { "shorthand_fetch_refspec1", &test_network_remote_local__shorthand_fetch_refspec1 },
    { "tagopt", &test_network_remote_local__tagopt },
    { "push_to_bare_remote", &test_network_remote_local__push_to_bare_remote },
    { "push_to_non_bare_remote", &test_network_remote_local__push_to_non_bare_remote }
};
static const struct clar_func _clar_cb_index_stage[] = {
    { "add_always_adds_stage_0", &test_index_stage__add_always_adds_stage_0 },
    { "find_gets_first_stage", &test_index_stage__find_gets_first_stage }
};
static const struct clar_func _clar_cb_blame_simple[] = {
    { "trivial_testrepo", &test_blame_simple__trivial_testrepo },
    { "trivial_blamerepo", &test_blame_simple__trivial_blamerepo },
    { "trivial_libgit2", &test_blame_simple__trivial_libgit2 },
    { "can_restrict_lines_min", &test_blame_simple__can_restrict_lines_min },
    { "can_restrict_lines_max", &test_blame_simple__can_restrict_lines_max },
    { "can_restrict_lines_both", &test_blame_simple__can_restrict_lines_both },
    { "can_restrict_to_newish_commits", &test_blame_simple__can_restrict_to_newish_commits }
};
static const struct clar_func _clar_cb_config_stress[] = {
    { "dont_break_on_invalid_input", &test_config_stress__dont_break_on_invalid_input },
    { "comments", &test_config_stress__comments },
    { "escape_subsection_names", &test_config_stress__escape_subsection_names },
    { "trailing_backslash", &test_config_stress__trailing_backslash }
};
static const struct clar_func _clar_cb_core_copy[] = {
    { "file", &test_core_copy__file },
    { "file_in_dir", &test_core_copy__file_in_dir },
    { "tree", &test_core_copy__tree }
};
static const struct clar_func _clar_cb_diff_submodules[] = {
    { "unmodified_submodule", &test_diff_submodules__unmodified_submodule },
    { "dirty_submodule", &test_diff_submodules__dirty_submodule },
    { "dirty_submodule_2", &test_diff_submodules__dirty_submodule_2 },
    { "submod2_index_to_wd", &test_diff_submodules__submod2_index_to_wd },
    { "submod2_head_to_index", &test_diff_submodules__submod2_head_to_index },
    { "invalid_cache", &test_diff_submodules__invalid_cache },
    { "diff_ignore_options", &test_diff_submodules__diff_ignore_options }
};
static const struct clar_func _clar_cb_object_raw_type2string[] = {
    { "convert_type_to_string", &test_object_raw_type2string__convert_type_to_string },
    { "convert_string_to_type", &test_object_raw_type2string__convert_string_to_type },
    { "check_type_is_loose", &test_object_raw_type2string__check_type_is_loose }
};
static const struct clar_func _clar_cb_object_tree_write[] = {
    { "from_memory", &test_object_tree_write__from_memory },
    { "subtree", &test_object_tree_write__subtree },
    { "sorted_subtrees", &test_object_tree_write__sorted_subtrees },
    { "removing_and_re_adding_in_treebuilder", &test_object_tree_write__removing_and_re_adding_in_treebuilder }
};
static const struct clar_func _clar_cb_config_write[] = {
    { "replace_value", &test_config_write__replace_value },
    { "delete_value", &test_config_write__delete_value },
    { "delete_value_at_specific_level", &test_config_write__delete_value_at_specific_level },
    { "write_subsection", &test_config_write__write_subsection },
    { "delete_inexistent", &test_config_write__delete_inexistent },
    { "value_containing_quotes", &test_config_write__value_containing_quotes },
    { "escape_value", &test_config_write__escape_value },
    { "add_value_at_specific_level", &test_config_write__add_value_at_specific_level },
    { "add_value_at_file_with_no_clrf_at_the_end", &test_config_write__add_value_at_file_with_no_clrf_at_the_end },
    { "add_value_which_needs_quotes", &test_config_write__add_value_which_needs_quotes },
    { "can_set_a_value_to_NULL", &test_config_write__can_set_a_value_to_NULL },
    { "can_set_an_empty_value", &test_config_write__can_set_an_empty_value },
    { "updating_a_locked_config_file_returns_ELOCKED", &test_config_write__updating_a_locked_config_file_returns_ELOCKED }
};
static const struct clar_func _clar_cb_status_renames[] = {
    { "head2index_one", &test_status_renames__head2index_one },
    { "head2index_two", &test_status_renames__head2index_two },
    { "head2index_no_rename_from_rewrite", &test_status_renames__head2index_no_rename_from_rewrite },
    { "head2index_rename_from_rewrite", &test_status_renames__head2index_rename_from_rewrite },
    { "index2workdir_one", &test_status_renames__index2workdir_one },
    { "index2workdir_two", &test_status_renames__index2workdir_two },
    { "index2workdir_rename_from_rewrite", &test_status_renames__index2workdir_rename_from_rewrite },
    { "both_one", &test_status_renames__both_one },
    { "both_two", &test_status_renames__both_two },
    { "both_rename_from_rewrite", &test_status_renames__both_rename_from_rewrite },
    { "rewrites_only_for_renames", &test_status_renames__rewrites_only_for_renames },
    { "both_casechange_one", &test_status_renames__both_casechange_one },
    { "both_casechange_two", &test_status_renames__both_casechange_two }
};
static const struct clar_func _clar_cb_merge_trees_automerge[] = {
    { "automerge", &test_merge_trees_automerge__automerge },
    { "favor_ours", &test_merge_trees_automerge__favor_ours },
    { "favor_theirs", &test_merge_trees_automerge__favor_theirs },
    { "unrelated", &test_merge_trees_automerge__unrelated }
};
static const struct clar_func _clar_cb_object_tree_attributes[] = {
    { "ensure_correctness_of_attributes_on_insertion", &test_object_tree_attributes__ensure_correctness_of_attributes_on_insertion },
    { "group_writable_tree_entries_created_with_an_antique_git_version_can_still_be_accessed", &test_object_tree_attributes__group_writable_tree_entries_created_with_an_antique_git_version_can_still_be_accessed },
    { "treebuilder_reject_invalid_filemode", &test_object_tree_attributes__treebuilder_reject_invalid_filemode },
    { "normalize_attributes_when_creating_a_tree_from_an_existing_one", &test_object_tree_attributes__normalize_attributes_when_creating_a_tree_from_an_existing_one },
    { "normalize_600", &test_object_tree_attributes__normalize_600 }
};
static const struct clar_func _clar_cb_checkout_crlf[] = {
    { "detect_crlf_autocrlf_false", &test_checkout_crlf__detect_crlf_autocrlf_false },
    { "autocrlf_false_index_size_is_unfiltered_size", &test_checkout_crlf__autocrlf_false_index_size_is_unfiltered_size },
    { "detect_crlf_autocrlf_true", &test_checkout_crlf__detect_crlf_autocrlf_true },
    { "more_lf_autocrlf_true", &test_checkout_crlf__more_lf_autocrlf_true },
    { "more_crlf_autocrlf_true", &test_checkout_crlf__more_crlf_autocrlf_true },
    { "all_crlf_autocrlf_true", &test_checkout_crlf__all_crlf_autocrlf_true },
    { "autocrlf_true_index_size_is_filtered_size", &test_checkout_crlf__autocrlf_true_index_size_is_filtered_size },
    { "with_ident", &test_checkout_crlf__with_ident }
};
static const struct clar_func _clar_cb_config_multivar[] = {
    { "foreach", &test_config_multivar__foreach },
    { "get", &test_config_multivar__get },
    { "add", &test_config_multivar__add },
    { "add_new", &test_config_multivar__add_new },
    { "replace", &test_config_multivar__replace },
    { "replace_multiple", &test_config_multivar__replace_multiple },
    { "delete", &test_config_multivar__delete },
    { "delete_multiple", &test_config_multivar__delete_multiple },
    { "delete_notfound", &test_config_multivar__delete_notfound }
};
static const struct clar_func _clar_cb_network_urlparse[] = {
    { "trivial", &test_network_urlparse__trivial },
    { "encoded_password", &test_network_urlparse__encoded_password },
    { "user", &test_network_urlparse__user },
    { "user_pass", &test_network_urlparse__user_pass },
    { "port", &test_network_urlparse__port },
    { "user_port", &test_network_urlparse__user_port },
    { "user_pass_port", &test_network_urlparse__user_pass_port },
    { "connection_data_http", &test_network_urlparse__connection_data_http },
    { "connection_data_ssl", &test_network_urlparse__connection_data_ssl },
    { "encoded_username_password", &test_network_urlparse__encoded_username_password },
    { "connection_data_cross_host_redirect", &test_network_urlparse__connection_data_cross_host_redirect },
    { "connection_data_http_downgrade", &test_network_urlparse__connection_data_http_downgrade },
    { "connection_data_relative_redirect", &test_network_urlparse__connection_data_relative_redirect },
    { "connection_data_relative_redirect_ssl", &test_network_urlparse__connection_data_relative_redirect_ssl },
    { "connection_data_cleanup", &test_network_urlparse__connection_data_cleanup }
};
static const struct clar_func _clar_cb_merge_workdir_trivial[] = {
    { "2alt", &test_merge_workdir_trivial__2alt },
    { "3alt", &test_merge_workdir_trivial__3alt },
    { "4", &test_merge_workdir_trivial__4 },
    { "5alt_1", &test_merge_workdir_trivial__5alt_1 },
    { "5alt_2", &test_merge_workdir_trivial__5alt_2 },
    { "6", &test_merge_workdir_trivial__6 },
    { "6_automerge", &test_merge_workdir_trivial__6_automerge },
    { "8", &test_merge_workdir_trivial__8 },
    { "8_automerge", &test_merge_workdir_trivial__8_automerge },
    { "7", &test_merge_workdir_trivial__7 },
    { "7_automerge", &test_merge_workdir_trivial__7_automerge },
    { "10", &test_merge_workdir_trivial__10 },
    { "10_automerge", &test_merge_workdir_trivial__10_automerge },
    { "9", &test_merge_workdir_trivial__9 },
    { "9_automerge", &test_merge_workdir_trivial__9_automerge },
    { "13", &test_merge_workdir_trivial__13 },
    { "14", &test_merge_workdir_trivial__14 },
    { "11", &test_merge_workdir_trivial__11 }
};
static const struct clar_func _clar_cb_filter_crlf[] = {
    { "to_worktree", &test_filter_crlf__to_worktree },
    { "to_odb", &test_filter_crlf__to_odb }
};
static const struct clar_func _clar_cb_network_remote_remotes[] = {
    { "parsing", &test_network_remote_remotes__parsing },
    { "pushurl", &test_network_remote_remotes__pushurl },
    { "error_when_no_push_available", &test_network_remote_remotes__error_when_no_push_available },
    { "parsing_ssh_remote", &test_network_remote_remotes__parsing_ssh_remote },
    { "parsing_local_path_fails_if_path_not_found", &test_network_remote_remotes__parsing_local_path_fails_if_path_not_found },
    { "supported_transport_methods_are_supported", &test_network_remote_remotes__supported_transport_methods_are_supported },
    { "unsupported_transport_methods_are_unsupported", &test_network_remote_remotes__unsupported_transport_methods_are_unsupported },
    { "refspec_parsing", &test_network_remote_remotes__refspec_parsing },
    { "add_fetchspec", &test_network_remote_remotes__add_fetchspec },
    { "add_pushspec", &test_network_remote_remotes__add_pushspec },
    { "save", &test_network_remote_remotes__save },
    { "fnmatch", &test_network_remote_remotes__fnmatch },
    { "transform", &test_network_remote_remotes__transform },
    { "transform_destination_to_source", &test_network_remote_remotes__transform_destination_to_source },
    { "transform_r", &test_network_remote_remotes__transform_r },
    { "missing_refspecs", &test_network_remote_remotes__missing_refspecs },
    { "list", &test_network_remote_remotes__list },
    { "loading_a_missing_remote_returns_ENOTFOUND", &test_network_remote_remotes__loading_a_missing_remote_returns_ENOTFOUND },
    { "loading_with_an_invalid_name_returns_EINVALIDSPEC", &test_network_remote_remotes__loading_with_an_invalid_name_returns_EINVALIDSPEC },
    { "add", &test_network_remote_remotes__add },
    { "cannot_add_a_nameless_remote", &test_network_remote_remotes__cannot_add_a_nameless_remote },
    { "cannot_save_an_inmemory_remote", &test_network_remote_remotes__cannot_save_an_inmemory_remote },
    { "cannot_add_a_remote_with_an_invalid_name", &test_network_remote_remotes__cannot_add_a_remote_with_an_invalid_name },
    { "tagopt", &test_network_remote_remotes__tagopt },
    { "can_load_with_an_empty_url", &test_network_remote_remotes__can_load_with_an_empty_url },
    { "can_load_with_only_an_empty_pushurl", &test_network_remote_remotes__can_load_with_only_an_empty_pushurl },
    { "returns_ENOTFOUND_when_neither_url_nor_pushurl", &test_network_remote_remotes__returns_ENOTFOUND_when_neither_url_nor_pushurl },
    { "check_structure_version", &test_network_remote_remotes__check_structure_version },
    { "cannot_create_a_remote_which_name_conflicts_with_an_existing_remote", &test_network_remote_remotes__cannot_create_a_remote_which_name_conflicts_with_an_existing_remote },
    { "cannot_create_a_remote_which_name_is_invalid", &test_network_remote_remotes__cannot_create_a_remote_which_name_is_invalid },
    { "query_refspecs", &test_network_remote_remotes__query_refspecs }
};
static const struct clar_func _clar_cb_attr_flags[] = {
    { "bare", &test_attr_flags__bare },
    { "index_vs_workdir", &test_attr_flags__index_vs_workdir },
    { "subdir", &test_attr_flags__subdir }
};
static const struct clar_func _clar_cb_repo_iterator[] = {
    { "index", &test_repo_iterator__index },
    { "index_icase", &test_repo_iterator__index_icase },
    { "tree", &test_repo_iterator__tree },
    { "tree_icase", &test_repo_iterator__tree_icase },
    { "tree_more", &test_repo_iterator__tree_more },
    { "tree_case_conflicts_0", &test_repo_iterator__tree_case_conflicts_0 },
    { "tree_case_conflicts_1", &test_repo_iterator__tree_case_conflicts_1 },
    { "tree_case_conflicts_2", &test_repo_iterator__tree_case_conflicts_2 },
    { "workdir", &test_repo_iterator__workdir },
    { "workdir_icase", &test_repo_iterator__workdir_icase },
    { "workdir_depth", &test_repo_iterator__workdir_depth },
    { "fs", &test_repo_iterator__fs },
    { "fs2", &test_repo_iterator__fs2 },
    { "fs_preserves_error", &test_repo_iterator__fs_preserves_error }
};
static const struct clar_func _clar_cb_refs_crashes[] = {
    { "double_free", &test_refs_crashes__double_free }
};
static const struct clar_func _clar_cb_refs_isvalidname[] = {
    { "can_detect_invalid_formats", &test_refs_isvalidname__can_detect_invalid_formats },
    { "wont_hopefully_choke_on_valid_formats", &test_refs_isvalidname__wont_hopefully_choke_on_valid_formats }
};
static const struct clar_func _clar_cb_merge_trees_renames[] = {
    { "index", &test_merge_trees_renames__index },
    { "no_rename_index", &test_merge_trees_renames__no_rename_index }
};
static const struct clar_func _clar_cb_network_remote_createthenload[] = {
    { "parsing", &test_network_remote_createthenload__parsing }
};
static const struct clar_func _clar_cb_odb_packed[] = {
    { "mass_read", &test_odb_packed__mass_read },
    { "read_header_0", &test_odb_packed__read_header_0 },
    { "read_header_1", &test_odb_packed__read_header_1 }
};
static const struct clar_func _clar_cb_attr_repo[] = {
    { "get_one", &test_attr_repo__get_one },
    { "get_many", &test_attr_repo__get_many },
    { "get_many_in_place", &test_attr_repo__get_many_in_place },
    { "foreach", &test_attr_repo__foreach },
    { "manpage_example", &test_attr_repo__manpage_example },
    { "macros", &test_attr_repo__macros },
    { "bad_macros", &test_attr_repo__bad_macros },
    { "staging_properly_normalizes_line_endings_according_to_gitattributes_directives", &test_attr_repo__staging_properly_normalizes_line_endings_according_to_gitattributes_directives }
};
static const struct clar_func _clar_cb_refs_reflog_drop[] = {
    { "dropping_a_non_exisiting_entry_from_the_log_returns_ENOTFOUND", &test_refs_reflog_drop__dropping_a_non_exisiting_entry_from_the_log_returns_ENOTFOUND },
    { "can_drop_an_entry", &test_refs_reflog_drop__can_drop_an_entry },
    { "can_drop_an_entry_and_rewrite_the_log_history", &test_refs_reflog_drop__can_drop_an_entry_and_rewrite_the_log_history },
    { "can_drop_the_oldest_entry", &test_refs_reflog_drop__can_drop_the_oldest_entry },
    { "can_drop_the_oldest_entry_and_rewrite_the_log_history", &test_refs_reflog_drop__can_drop_the_oldest_entry_and_rewrite_the_log_history },
    { "can_drop_all_the_entries", &test_refs_reflog_drop__can_drop_all_the_entries },
    { "can_persist_deletion_on_disk", &test_refs_reflog_drop__can_persist_deletion_on_disk }
};
static const struct clar_func _clar_cb_online_push[] = {
    { "noop", &test_online_push__noop },
    { "b1", &test_online_push__b1 },
    { "b2", &test_online_push__b2 },
    { "b3", &test_online_push__b3 },
    { "b4", &test_online_push__b4 },
    { "b5", &test_online_push__b5 },
    { "multi", &test_online_push__multi },
    { "implicit_tgt", &test_online_push__implicit_tgt },
    { "fast_fwd", &test_online_push__fast_fwd },
    { "tag_commit", &test_online_push__tag_commit },
    { "tag_tree", &test_online_push__tag_tree },
    { "tag_blob", &test_online_push__tag_blob },
    { "tag_lightweight", &test_online_push__tag_lightweight },
    { "tag_to_tag", &test_online_push__tag_to_tag },
    { "force", &test_online_push__force },
    { "delete", &test_online_push__delete },
    { "bad_refspecs", &test_online_push__bad_refspecs },
    { "expressions", &test_online_push__expressions },
    { "notes", &test_online_push__notes }
};
static const struct clar_func _clar_cb_trace_trace[] = {
    { "sets", &test_trace_trace__sets },
    { "can_reset", &test_trace_trace__can_reset },
    { "can_unset", &test_trace_trace__can_unset },
    { "skips_higher_level", &test_trace_trace__skips_higher_level },
    { "writes", &test_trace_trace__writes },
    { "writes_lower_level", &test_trace_trace__writes_lower_level }
};
static const struct clar_func _clar_cb_object_tree_read[] = {
    { "loaded", &test_object_tree_read__loaded },
    { "two", &test_object_tree_read__two }
};
static const struct clar_func _clar_cb_index_rename[] = {
    { "single_file", &test_index_rename__single_file }
};
static const struct clar_func _clar_cb_blame_buffer[] = {
    { "added_line", &test_blame_buffer__added_line },
    { "deleted_line", &test_blame_buffer__deleted_line },
    { "add_splits_hunk", &test_blame_buffer__add_splits_hunk },
    { "delete_crosses_hunk_boundary", &test_blame_buffer__delete_crosses_hunk_boundary },
    { "replace_line", &test_blame_buffer__replace_line },
    { "add_lines_at_end", &test_blame_buffer__add_lines_at_end }
};
static const struct clar_func _clar_cb_status_worktree_init[] = {
    { "cannot_retrieve_the_status_of_a_bare_repository", &test_status_worktree_init__cannot_retrieve_the_status_of_a_bare_repository },
    { "first_commit_in_progress", &test_status_worktree_init__first_commit_in_progress },
    { "status_file_without_index_or_workdir", &test_status_worktree_init__status_file_without_index_or_workdir },
    { "status_file_with_clean_index_and_empty_workdir", &test_status_worktree_init__status_file_with_clean_index_and_empty_workdir },
    { "bracket_in_filename", &test_status_worktree_init__bracket_in_filename },
    { "space_in_filename", &test_status_worktree_init__space_in_filename },
    { "disable_pathspec_match", &test_status_worktree_init__disable_pathspec_match },
    { "new_staged_file_must_handle_crlf", &test_status_worktree_init__new_staged_file_must_handle_crlf }
};
static const struct clar_func _clar_cb_pack_packbuilder[] = {
    { "create_pack", &test_pack_packbuilder__create_pack },
    { "get_hash", &test_pack_packbuilder__get_hash },
    { "permissions_standard", &test_pack_packbuilder__permissions_standard },
    { "permissions_readonly", &test_pack_packbuilder__permissions_readonly },
    { "permissions_readwrite", &test_pack_packbuilder__permissions_readwrite },
    { "foreach", &test_pack_packbuilder__foreach }
};
static const struct clar_func _clar_cb_diff_index[] = {
    { "0", &test_diff_index__0 },
    { "1", &test_diff_index__1 },
    { "checks_options_version", &test_diff_index__checks_options_version }
};
static const struct clar_func _clar_cb_object_raw_size[] = {
    { "validate_oid_size", &test_object_raw_size__validate_oid_size }
};
static const struct clar_func _clar_cb_revwalk_basic[] = {
    { "sorting_modes", &test_revwalk_basic__sorting_modes },
    { "glob_heads", &test_revwalk_basic__glob_heads },
    { "glob_heads_with_invalid", &test_revwalk_basic__glob_heads_with_invalid },
    { "push_head", &test_revwalk_basic__push_head },
    { "push_head_hide_ref", &test_revwalk_basic__push_head_hide_ref },
    { "push_head_hide_ref_nobase", &test_revwalk_basic__push_head_hide_ref_nobase },
    { "disallow_non_commit", &test_revwalk_basic__disallow_non_commit },
    { "push_range", &test_revwalk_basic__push_range }
};
static const struct clar_func _clar_cb_object_raw_hash[] = {
    { "hash_by_blocks", &test_object_raw_hash__hash_by_blocks },
    { "hash_buffer_in_single_call", &test_object_raw_hash__hash_buffer_in_single_call },
    { "hash_vector", &test_object_raw_hash__hash_vector },
    { "hash_junk_data", &test_object_raw_hash__hash_junk_data },
    { "hash_commit_object", &test_object_raw_hash__hash_commit_object },
    { "hash_tree_object", &test_object_raw_hash__hash_tree_object },
    { "hash_tag_object", &test_object_raw_hash__hash_tag_object },
    { "hash_zero_length_object", &test_object_raw_hash__hash_zero_length_object },
    { "hash_one_byte_object", &test_object_raw_hash__hash_one_byte_object },
    { "hash_two_byte_object", &test_object_raw_hash__hash_two_byte_object },
    { "hash_multi_byte_object", &test_object_raw_hash__hash_multi_byte_object }
};
static const struct clar_func _clar_cb_checkout_binaryunicode[] = {
    { "noautocrlf", &test_checkout_binaryunicode__noautocrlf },
    { "autocrlf", &test_checkout_binaryunicode__autocrlf }
};
static const struct clar_func _clar_cb_refs_peel[] = {
    { "can_peel_a_tag", &test_refs_peel__can_peel_a_tag },
    { "can_peel_a_branch", &test_refs_peel__can_peel_a_branch },
    { "can_peel_a_symbolic_reference", &test_refs_peel__can_peel_a_symbolic_reference },
    { "cannot_peel_into_a_non_existing_target", &test_refs_peel__cannot_peel_into_a_non_existing_target },
    { "can_peel_into_any_non_tag_object", &test_refs_peel__can_peel_into_any_non_tag_object },
    { "can_peel_fully_peeled_packed_refs", &test_refs_peel__can_peel_fully_peeled_packed_refs }
};
static const struct clar_func _clar_cb_submodule_modify[] = {
    { "add", &test_submodule_modify__add },
    { "init", &test_submodule_modify__init },
    { "sync", &test_submodule_modify__sync },
    { "edit_and_save", &test_submodule_modify__edit_and_save }
};
static const struct clar_func _clar_cb_object_blob_filter[] = {
    { "unfiltered", &test_object_blob_filter__unfiltered },
    { "stats", &test_object_blob_filter__stats },
    { "to_odb", &test_object_blob_filter__to_odb }
};
static const struct clar_func _clar_cb_network_cred[] = {
    { "stock_userpass_validates_args", &test_network_cred__stock_userpass_validates_args },
    { "stock_userpass_validates_that_method_is_allowed", &test_network_cred__stock_userpass_validates_that_method_is_allowed },
    { "stock_userpass_properly_handles_username_in_url", &test_network_cred__stock_userpass_properly_handles_username_in_url }
};
static const struct clar_func _clar_cb_core_strtol[] = {
    { "int32", &test_core_strtol__int32 },
    { "int64", &test_core_strtol__int64 }
};
static const struct clar_func _clar_cb_refs_branches_lookup[] = {
    { "can_retrieve_a_local_branch", &test_refs_branches_lookup__can_retrieve_a_local_branch },
    { "can_retrieve_a_remote_tracking_branch", &test_refs_branches_lookup__can_retrieve_a_remote_tracking_branch },
    { "trying_to_retrieve_an_unknown_branch_returns_ENOTFOUND", &test_refs_branches_lookup__trying_to_retrieve_an_unknown_branch_returns_ENOTFOUND },
    { "trying_to_retrieve_a_branch_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_branches_lookup__trying_to_retrieve_a_branch_with_an_invalid_name_returns_EINVALIDSPEC }
};
static const struct clar_func _clar_cb_core_stat[] = {
    { "0", &test_core_stat__0 }
};
static const struct clar_func _clar_cb_core_pool[] = {
    { "0", &test_core_pool__0 },
    { "1", &test_core_pool__1 },
    { "2", &test_core_pool__2 },
    { "free_list", &test_core_pool__free_list },
    { "strndup_limit", &test_core_pool__strndup_limit }
};
static const struct clar_func _clar_cb_stash_foreach[] = {
    { "enumerating_a_empty_repository_doesnt_fail", &test_stash_foreach__enumerating_a_empty_repository_doesnt_fail },
    { "can_enumerate_a_repository", &test_stash_foreach__can_enumerate_a_repository }
};
static const struct clar_func _clar_cb_status_single[] = {
    { "hash_single_file", &test_status_single__hash_single_file },
    { "hash_single_empty_file", &test_status_single__hash_single_empty_file }
};
static const struct clar_func _clar_cb_notes_notes[] = {
    { "can_retrieve_a_list_of_notes_for_a_given_namespace", &test_notes_notes__can_retrieve_a_list_of_notes_for_a_given_namespace },
    { "can_cancel_foreach", &test_notes_notes__can_cancel_foreach },
    { "retrieving_a_list_of_notes_for_an_unknown_namespace_returns_ENOTFOUND", &test_notes_notes__retrieving_a_list_of_notes_for_an_unknown_namespace_returns_ENOTFOUND },
    { "inserting_a_note_without_passing_a_namespace_uses_the_default_namespace", &test_notes_notes__inserting_a_note_without_passing_a_namespace_uses_the_default_namespace },
    { "can_insert_a_note_with_a_custom_namespace", &test_notes_notes__can_insert_a_note_with_a_custom_namespace },
    { "creating_a_note_on_a_target_which_already_has_one_returns_EEXISTS", &test_notes_notes__creating_a_note_on_a_target_which_already_has_one_returns_EEXISTS },
    { "creating_a_note_on_a_target_can_overwrite_existing_note", &test_notes_notes__creating_a_note_on_a_target_can_overwrite_existing_note },
    { "can_insert_a_note_in_an_existing_fanout", &test_notes_notes__can_insert_a_note_in_an_existing_fanout },
    { "can_read_a_note_in_an_existing_fanout", &test_notes_notes__can_read_a_note_in_an_existing_fanout },
    { "can_remove_a_note_in_an_existing_fanout", &test_notes_notes__can_remove_a_note_in_an_existing_fanout },
    { "removing_a_note_which_doesnt_exists_returns_ENOTFOUND", &test_notes_notes__removing_a_note_which_doesnt_exists_returns_ENOTFOUND },
    { "can_iterate_default_namespace", &test_notes_notes__can_iterate_default_namespace },
    { "can_iterate_custom_namespace", &test_notes_notes__can_iterate_custom_namespace },
    { "empty_iterate", &test_notes_notes__empty_iterate }
};
static const struct clar_func _clar_cb_reset_soft[] = {
    { "can_reset_the_non_detached_Head_to_the_specified_commit", &test_reset_soft__can_reset_the_non_detached_Head_to_the_specified_commit },
    { "can_reset_the_detached_Head_to_the_specified_commit", &test_reset_soft__can_reset_the_detached_Head_to_the_specified_commit },
    { "resetting_to_the_commit_pointed_at_by_the_Head_does_not_change_the_target_of_the_Head", &test_reset_soft__resetting_to_the_commit_pointed_at_by_the_Head_does_not_change_the_target_of_the_Head },
    { "resetting_to_a_tag_sets_the_Head_to_the_peeled_commit", &test_reset_soft__resetting_to_a_tag_sets_the_Head_to_the_peeled_commit },
    { "cannot_reset_to_a_tag_not_pointing_at_a_commit", &test_reset_soft__cannot_reset_to_a_tag_not_pointing_at_a_commit },
    { "resetting_against_an_unborn_head_repo_makes_the_head_no_longer_unborn", &test_reset_soft__resetting_against_an_unborn_head_repo_makes_the_head_no_longer_unborn },
    { "fails_when_merging", &test_reset_soft__fails_when_merging },
    { "fails_when_index_contains_conflicts_independently_of_MERGE_HEAD_file_existence", &test_reset_soft__fails_when_index_contains_conflicts_independently_of_MERGE_HEAD_file_existence }
};
static const struct clar_func _clar_cb_object_tree_frompath[] = {
    { "retrieve_tree_from_path_to_treeentry", &test_object_tree_frompath__retrieve_tree_from_path_to_treeentry },
    { "fail_when_processing_an_invalid_path", &test_object_tree_frompath__fail_when_processing_an_invalid_path }
};
static const struct clar_func _clar_cb_refs_delete[] = {
    { "packed_loose", &test_refs_delete__packed_loose },
    { "packed_only", &test_refs_delete__packed_only }
};
static const struct clar_func _clar_cb_merge_trees_treediff[] = {
    { "simple", &test_merge_trees_treediff__simple },
    { "df_conflicts", &test_merge_trees_treediff__df_conflicts },
    { "strict_renames", &test_merge_trees_treediff__strict_renames },
    { "rename_conflicts", &test_merge_trees_treediff__rename_conflicts },
    { "best_renames", &test_merge_trees_treediff__best_renames }
};
static const struct clar_func _clar_cb_online_fetch[] = {
    { "default_git", &test_online_fetch__default_git },
    { "default_http", &test_online_fetch__default_http },
    { "default_https", &test_online_fetch__default_https },
    { "no_tags_git", &test_online_fetch__no_tags_git },
    { "no_tags_http", &test_online_fetch__no_tags_http },
    { "doesnt_retrieve_a_pack_when_the_repository_is_up_to_date", &test_online_fetch__doesnt_retrieve_a_pack_when_the_repository_is_up_to_date },
    { "can_cancel", &test_online_fetch__can_cancel },
    { "ls_disconnected", &test_online_fetch__ls_disconnected }
};
static const struct clar_func _clar_cb_object_lookupbypath[] = {
    { "errors", &test_object_lookupbypath__errors },
    { "from_root_tree", &test_object_lookupbypath__from_root_tree },
    { "from_head_commit", &test_object_lookupbypath__from_head_commit },
    { "from_subdir_tree", &test_object_lookupbypath__from_subdir_tree }
};
static const struct clar_func _clar_cb_object_tag_list[] = {
    { "list_all", &test_object_tag_list__list_all },
    { "list_by_pattern", &test_object_tag_list__list_by_pattern }
};
static const struct clar_func _clar_cb_config_global[] = {
    { "open_global", &test_config_global__open_global },
    { "open_xdg", &test_config_global__open_xdg }
};
static const struct clar_func _clar_cb_buf_splice[] = {
    { "preprend", &test_buf_splice__preprend },
    { "append", &test_buf_splice__append },
    { "insert_at", &test_buf_splice__insert_at },
    { "remove_at", &test_buf_splice__remove_at },
    { "replace", &test_buf_splice__replace },
    { "replace_with_longer", &test_buf_splice__replace_with_longer },
    { "replace_with_shorter", &test_buf_splice__replace_with_shorter },
    { "truncate", &test_buf_splice__truncate },
    { "dont_do_anything", &test_buf_splice__dont_do_anything }
};
static const struct clar_func _clar_cb_refs_branches_remote[] = {
    { "can_get_remote_for_branch", &test_refs_branches_remote__can_get_remote_for_branch },
    { "insufficient_buffer_returns_error", &test_refs_branches_remote__insufficient_buffer_returns_error },
    { "no_matching_remote_returns_error", &test_refs_branches_remote__no_matching_remote_returns_error },
    { "local_remote_returns_error", &test_refs_branches_remote__local_remote_returns_error },
    { "ambiguous_remote_returns_error", &test_refs_branches_remote__ambiguous_remote_returns_error }
};
static const struct clar_func _clar_cb_stash_drop[] = {
    { "cannot_drop_from_an_empty_stash", &test_stash_drop__cannot_drop_from_an_empty_stash },
    { "cannot_drop_a_non_existing_stashed_state", &test_stash_drop__cannot_drop_a_non_existing_stashed_state },
    { "can_purge_the_stash_from_the_top", &test_stash_drop__can_purge_the_stash_from_the_top },
    { "can_purge_the_stash_from_the_bottom", &test_stash_drop__can_purge_the_stash_from_the_bottom },
    { "dropping_an_entry_rewrites_reflog_history", &test_stash_drop__dropping_an_entry_rewrites_reflog_history },
    { "dropping_the_last_entry_removes_the_stash", &test_stash_drop__dropping_the_last_entry_removes_the_stash },
    { "dropping_the_top_stash_updates_the_stash_reference", &test_stash_drop__dropping_the_top_stash_updates_the_stash_reference }
};
static const struct clar_func _clar_cb_clone_empty[] = {
    { "can_clone_an_empty_local_repo_barely", &test_clone_empty__can_clone_an_empty_local_repo_barely },
    { "can_clone_an_empty_local_repo", &test_clone_empty__can_clone_an_empty_local_repo },
    { "can_clone_an_empty_standard_repo", &test_clone_empty__can_clone_an_empty_standard_repo }
};
static const struct clar_func _clar_cb_object_message[] = {
    { "long_lines_without_spaces_should_be_unchanged", &test_object_message__long_lines_without_spaces_should_be_unchanged },
    { "lines_with_spaces_at_the_beginning_should_be_unchanged", &test_object_message__lines_with_spaces_at_the_beginning_should_be_unchanged },
    { "lines_with_intermediate_spaces_should_be_unchanged", &test_object_message__lines_with_intermediate_spaces_should_be_unchanged },
    { "consecutive_blank_lines_should_be_unified", &test_object_message__consecutive_blank_lines_should_be_unified },
    { "only_consecutive_blank_lines_should_be_completely_removed", &test_object_message__only_consecutive_blank_lines_should_be_completely_removed },
    { "consecutive_blank_lines_at_the_beginning_should_be_removed", &test_object_message__consecutive_blank_lines_at_the_beginning_should_be_removed },
    { "consecutive_blank_lines_at_the_end_should_be_removed", &test_object_message__consecutive_blank_lines_at_the_end_should_be_removed },
    { "text_without_newline_at_end_should_end_with_newline", &test_object_message__text_without_newline_at_end_should_end_with_newline },
    { "text_plus_spaces_without_newline_should_not_show_spaces_and_end_with_newline", &test_object_message__text_plus_spaces_without_newline_should_not_show_spaces_and_end_with_newline },
    { "text_plus_spaces_ending_with_newline_should_be_cleaned_and_newline_must_remain", &test_object_message__text_plus_spaces_ending_with_newline_should_be_cleaned_and_newline_must_remain },
    { "spaces_with_newline_at_end_should_be_replaced_with_empty_string", &test_object_message__spaces_with_newline_at_end_should_be_replaced_with_empty_string },
    { "spaces_without_newline_at_end_should_be_replaced_with_empty_string", &test_object_message__spaces_without_newline_at_end_should_be_replaced_with_empty_string },
    { "consecutive_text_lines_should_be_unchanged", &test_object_message__consecutive_text_lines_should_be_unchanged },
    { "strip_comments", &test_object_message__strip_comments },
    { "keep_comments", &test_object_message__keep_comments },
    { "message_prettify", &test_object_message__message_prettify }
};
static const struct clar_func _clar_cb_reset_mixed[] = {
    { "cannot_reset_in_a_bare_repository", &test_reset_mixed__cannot_reset_in_a_bare_repository },
    { "resetting_refreshes_the_index_to_the_commit_tree", &test_reset_mixed__resetting_refreshes_the_index_to_the_commit_tree }
};
static const struct clar_func _clar_cb_object_lookup[] = {
    { "lookup_wrong_type_returns_enotfound", &test_object_lookup__lookup_wrong_type_returns_enotfound },
    { "lookup_nonexisting_returns_enotfound", &test_object_lookup__lookup_nonexisting_returns_enotfound },
    { "lookup_wrong_type_by_abbreviated_id_returns_enotfound", &test_object_lookup__lookup_wrong_type_by_abbreviated_id_returns_enotfound },
    { "lookup_wrong_type_eventually_returns_enotfound", &test_object_lookup__lookup_wrong_type_eventually_returns_enotfound }
};
static const struct clar_func _clar_cb_object_peel[] = {
    { "peeling_an_object_into_its_own_type_returns_another_instance_of_it", &test_object_peel__peeling_an_object_into_its_own_type_returns_another_instance_of_it },
    { "can_peel_a_tag", &test_object_peel__can_peel_a_tag },
    { "can_peel_a_commit", &test_object_peel__can_peel_a_commit },
    { "cannot_peel_a_tree", &test_object_peel__cannot_peel_a_tree },
    { "cannot_peel_a_blob", &test_object_peel__cannot_peel_a_blob },
    { "target_any_object_for_type_change", &test_object_peel__target_any_object_for_type_change }
};
static const struct clar_func _clar_cb_repo_hashfile[] = {
    { "simple", &test_repo_hashfile__simple },
    { "filtered", &test_repo_hashfile__filtered }
};
static const struct clar_func _clar_cb_core_vector[] = {
    { "0", &test_core_vector__0 },
    { "1", &test_core_vector__1 },
    { "2", &test_core_vector__2 },
    { "3", &test_core_vector__3 },
    { "4", &test_core_vector__4 },
    { "5", &test_core_vector__5 },
    { "remove_matching", &test_core_vector__remove_matching }
};
static const struct clar_func _clar_cb_refs_branches_create[] = {
    { "can_create_a_local_branch", &test_refs_branches_create__can_create_a_local_branch },
    { "can_not_create_a_branch_if_its_name_collide_with_an_existing_one", &test_refs_branches_create__can_not_create_a_branch_if_its_name_collide_with_an_existing_one },
    { "can_force_create_over_an_existing_branch", &test_refs_branches_create__can_force_create_over_an_existing_branch },
    { "creating_a_branch_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_branches_create__creating_a_branch_with_an_invalid_name_returns_EINVALIDSPEC }
};
static const struct clar_func _clar_cb_object_raw_write[] = {
    { "loose_object", &test_object_raw_write__loose_object },
    { "loose_tree", &test_object_raw_write__loose_tree },
    { "loose_tag", &test_object_raw_write__loose_tag },
    { "zero_length", &test_object_raw_write__zero_length },
    { "one_byte", &test_object_raw_write__one_byte },
    { "two_byte", &test_object_raw_write__two_byte },
    { "several_bytes", &test_object_raw_write__several_bytes }
};
static const struct clar_func _clar_cb_refs_foreachglob[] = {
    { "retrieve_all_refs", &test_refs_foreachglob__retrieve_all_refs },
    { "retrieve_remote_branches", &test_refs_foreachglob__retrieve_remote_branches },
    { "retrieve_local_branches", &test_refs_foreachglob__retrieve_local_branches },
    { "retrieve_partially_named_references", &test_refs_foreachglob__retrieve_partially_named_references },
    { "can_cancel", &test_refs_foreachglob__can_cancel }
};
static const struct clar_func _clar_cb_repo_headtree[] = {
    { "can_retrieve_the_root_tree_from_a_detached_head", &test_repo_headtree__can_retrieve_the_root_tree_from_a_detached_head },
    { "can_retrieve_the_root_tree_from_a_non_detached_head", &test_repo_headtree__can_retrieve_the_root_tree_from_a_non_detached_head },
    { "when_head_is_unborn_returns_EUNBORNBRANCH", &test_repo_headtree__when_head_is_unborn_returns_EUNBORNBRANCH },
    { "when_head_is_missing_returns_ENOTFOUND", &test_repo_headtree__when_head_is_missing_returns_ENOTFOUND }
};
static const struct clar_func _clar_cb_attr_lookup[] = {
    { "simple", &test_attr_lookup__simple },
    { "match_variants", &test_attr_lookup__match_variants },
    { "assign_variants", &test_attr_lookup__assign_variants },
    { "check_attr_examples", &test_attr_lookup__check_attr_examples },
    { "from_buffer", &test_attr_lookup__from_buffer }
};
static const struct clar_func _clar_cb_config_read[] = {
    { "simple_read", &test_config_read__simple_read },
    { "case_sensitive", &test_config_read__case_sensitive },
    { "multiline_value", &test_config_read__multiline_value },
    { "subsection_header", &test_config_read__subsection_header },
    { "lone_variable", &test_config_read__lone_variable },
    { "number_suffixes", &test_config_read__number_suffixes },
    { "blank_lines", &test_config_read__blank_lines },
    { "invalid_ext_headers", &test_config_read__invalid_ext_headers },
    { "empty_files", &test_config_read__empty_files },
    { "symbol_headers", &test_config_read__symbol_headers },
    { "header_in_last_line", &test_config_read__header_in_last_line },
    { "prefixes", &test_config_read__prefixes },
    { "escaping_quotes", &test_config_read__escaping_quotes },
    { "foreach", &test_config_read__foreach },
    { "iterator", &test_config_read__iterator },
    { "foreach_match", &test_config_read__foreach_match },
    { "iterator_glob", &test_config_read__iterator_glob },
    { "whitespace_not_required_around_assignment", &test_config_read__whitespace_not_required_around_assignment },
    { "read_git_config_entry", &test_config_read__read_git_config_entry },
    { "local_config_overrides_global_config_overrides_system_config", &test_config_read__local_config_overrides_global_config_overrides_system_config },
    { "fallback_from_local_to_global_and_from_global_to_system", &test_config_read__fallback_from_local_to_global_and_from_global_to_system },
    { "simple_read_from_specific_level", &test_config_read__simple_read_from_specific_level },
    { "can_load_and_parse_an_empty_config_file", &test_config_read__can_load_and_parse_an_empty_config_file },
    { "corrupt_header", &test_config_read__corrupt_header },
    { "corrupt_header2", &test_config_read__corrupt_header2 },
    { "corrupt_header3", &test_config_read__corrupt_header3 },
    { "override_variable", &test_config_read__override_variable }
};
static const struct clar_func _clar_cb_config_add[] = {
    { "to_existing_section", &test_config_add__to_existing_section },
    { "to_new_section", &test_config_add__to_new_section }
};
static const struct clar_func _clar_cb_online_fetchhead[] = {
    { "wildcard_spec", &test_online_fetchhead__wildcard_spec },
    { "explicit_spec", &test_online_fetchhead__explicit_spec },
    { "no_merges", &test_online_fetchhead__no_merges }
};
static struct clar_suite _clar_suites[] = {
    {
        "attr::file",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_attr_file, 4, 1
    },
    {
        "attr::flags",
        { NULL, NULL },
        { "cleanup", &test_attr_flags__cleanup },
        _clar_cb_attr_flags, 3, 1
    },
    {
        "attr::ignore",
        { "initialize", &test_attr_ignore__initialize },
        { "cleanup", &test_attr_ignore__cleanup },
        _clar_cb_attr_ignore, 5, 1
    },
    {
        "attr::lookup",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_attr_lookup, 5, 1
    },
    {
        "attr::repo",
        { "initialize", &test_attr_repo__initialize },
        { "cleanup", &test_attr_repo__cleanup },
        _clar_cb_attr_repo, 8, 1
    },
    {
        "blame::buffer",
        { "initialize", &test_blame_buffer__initialize },
        { "cleanup", &test_blame_buffer__cleanup },
        _clar_cb_blame_buffer, 6, 1
    },
    {
        "blame::getters",
        { "initialize", &test_blame_getters__initialize },
        { "cleanup", &test_blame_getters__cleanup },
        _clar_cb_blame_getters, 2, 1
    },
    {
        "blame::harder",
        { "initialize", &test_blame_harder__initialize },
        { "cleanup", &test_blame_harder__cleanup },
        _clar_cb_blame_harder, 4, 1
    },
    {
        "blame::simple",
        { "initialize", &test_blame_simple__initialize },
        { "cleanup", &test_blame_simple__cleanup },
        _clar_cb_blame_simple, 7, 1
    },
    {
        "buf::basic",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_buf_basic, 2, 1
    },
    {
        "buf::splice",
        { "initialize", &test_buf_splice__initialize },
        { "cleanup", &test_buf_splice__cleanup },
        _clar_cb_buf_splice, 9, 1
    },
    {
        "checkout::binaryunicode",
        { "initialize", &test_checkout_binaryunicode__initialize },
        { "cleanup", &test_checkout_binaryunicode__cleanup },
        _clar_cb_checkout_binaryunicode, 2, 1
    },
    {
        "checkout::conflict",
        { "initialize", &test_checkout_conflict__initialize },
        { "cleanup", &test_checkout_conflict__cleanup },
        _clar_cb_checkout_conflict, 17, 1
    },
    {
        "checkout::crlf",
        { "initialize", &test_checkout_crlf__initialize },
        { "cleanup", &test_checkout_crlf__cleanup },
        _clar_cb_checkout_crlf, 8, 1
    },
    {
        "checkout::head",
        { "initialize", &test_checkout_head__initialize },
        { "cleanup", &test_checkout_head__cleanup },
        _clar_cb_checkout_head, 2, 1
    },
    {
        "checkout::index",
        { "initialize", &test_checkout_index__initialize },
        { "cleanup", &test_checkout_index__cleanup },
        _clar_cb_checkout_index, 25, 1
    },
    {
        "checkout::tree",
        { "initialize", &test_checkout_tree__initialize },
        { "cleanup", &test_checkout_tree__cleanup },
        _clar_cb_checkout_tree, 24, 1
    },
    {
        "checkout::typechange",
        { "initialize", &test_checkout_typechange__initialize },
        { "cleanup", &test_checkout_typechange__cleanup },
        _clar_cb_checkout_typechange, 2, 1
    },
    {
        "clone::empty",
        { "initialize", &test_clone_empty__initialize },
        { "cleanup", &test_clone_empty__cleanup },
        _clar_cb_clone_empty, 3, 1
    },
    {
        "clone::nonetwork",
        { "initialize", &test_clone_nonetwork__initialize },
        { "cleanup", &test_clone_nonetwork__cleanup },
        _clar_cb_clone_nonetwork, 13, 1
    },
    {
        "commit::commit",
        { "initialize", &test_commit_commit__initialize },
        { "cleanup", &test_commit_commit__cleanup },
        _clar_cb_commit_commit, 1, 1
    },
    {
        "commit::parent",
        { "initialize", &test_commit_parent__initialize },
        { "cleanup", &test_commit_parent__cleanup },
        _clar_cb_commit_parent, 1, 1
    },
    {
        "commit::parse",
        { "initialize", &test_commit_parse__initialize },
        { "cleanup", &test_commit_parse__cleanup },
        _clar_cb_commit_parse, 6, 1
    },
    {
        "commit::signature",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_commit_signature, 7, 1
    },
    {
        "commit::write",
        { "initialize", &test_commit_write__initialize },
        { "cleanup", &test_commit_write__cleanup },
        _clar_cb_commit_write, 2, 1
    },
    {
        "config::add",
        { "initialize", &test_config_add__initialize },
        { "cleanup", &test_config_add__cleanup },
        _clar_cb_config_add, 2, 1
    },
    {
        "config::backend",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_config_backend, 1, 1
    },
    {
        "config::configlevel",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_config_configlevel, 4, 1
    },
    {
        "config::global",
        { "initialize", &test_config_global__initialize },
        { "cleanup", &test_config_global__cleanup },
        _clar_cb_config_global, 2, 1
    },
    {
        "config::include",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_config_include, 6, 1
    },
    {
        "config::multivar",
        { "initialize", &test_config_multivar__initialize },
        { "cleanup", &test_config_multivar__cleanup },
        _clar_cb_config_multivar, 9, 1
    },
    {
        "config::new",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_config_new, 1, 1
    },
    {
        "config::read",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_config_read, 27, 1
    },
    {
        "config::refresh",
        { "initialize", &test_config_refresh__initialize },
        { "cleanup", &test_config_refresh__cleanup },
        _clar_cb_config_refresh, 2, 1
    },
    {
        "config::stress",
        { "initialize", &test_config_stress__initialize },
        { "cleanup", &test_config_stress__cleanup },
        _clar_cb_config_stress, 4, 1
    },
    {
        "config::validkeyname",
        { "initialize", &test_config_validkeyname__initialize },
        { "cleanup", &test_config_validkeyname__cleanup },
        _clar_cb_config_validkeyname, 2, 1
    },
    {
        "config::write",
        { "initialize", &test_config_write__initialize },
        { "cleanup", &test_config_write__cleanup },
        _clar_cb_config_write, 13, 1
    },
    {
        "core::bitvec",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_bitvec, 1, 1
    },
    {
        "core::buffer",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_buffer, 20, 1
    },
    {
        "core::caps",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_caps, 1, 1
    },
    {
        "core::copy",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_copy, 3, 1
    },
    {
        "core::dirent",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_dirent, 7, 1
    },
    {
        "core::env",
        { "initialize", &test_core_env__initialize },
        { "cleanup", &test_core_env__cleanup },
        _clar_cb_core_env, 3, 1
    },
    {
        "core::errors",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_errors, 2, 1
    },
    {
        "core::filebuf",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_filebuf, 6, 1
    },
    {
        "core::hex",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_hex, 1, 1
    },
    {
        "core::iconv",
        { "initialize", &test_core_iconv__initialize },
        { "cleanup", &test_core_iconv__cleanup },
        _clar_cb_core_iconv, 3, 1
    },
    {
        "core::mkdir",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_mkdir, 3, 1
    },
    {
        "core::oid",
        { "initialize", &test_core_oid__initialize },
        { NULL, NULL },
        _clar_cb_core_oid, 3, 1
    },
    {
        "core::oidmap",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_oidmap, 2, 1
    },
    {
        "core::opts",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_opts, 1, 1
    },
    {
        "core::path",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_path, 14, 1
    },
    {
        "core::pool",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_pool, 5, 1
    },
    {
        "core::posix",
        { "initialize", &test_core_posix__initialize },
        { NULL, NULL },
        _clar_cb_core_posix, 1, 1
    },
    {
        "core::rmdir",
        { "initialize", &test_core_rmdir__initialize },
        { NULL, NULL },
        _clar_cb_core_rmdir, 4, 1
    },
    {
        "core::sortedcache",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_sortedcache, 3, 1
    },
    {
        "core::stat",
        { "initialize", &test_core_stat__initialize },
        { "cleanup", &test_core_stat__cleanup },
        _clar_cb_core_stat, 1, 1
    },
    {
        "core::string",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_string, 3, 1
    },
    {
        "core::strmap",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_strmap, 4, 1
    },
    {
        "core::strtol",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_strtol, 2, 1
    },
    {
        "core::vector",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_vector, 7, 1
    },
    {
        "date::date",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_date_date, 1, 1
    },
    {
        "diff::blob",
        { "initialize", &test_diff_blob__initialize },
        { "cleanup", &test_diff_blob__cleanup },
        _clar_cb_diff_blob, 17, 1
    },
    {
        "diff::diffiter",
        { "initialize", &test_diff_diffiter__initialize },
        { "cleanup", &test_diff_diffiter__cleanup },
        _clar_cb_diff_diffiter, 9, 1
    },
    {
        "diff::drivers",
        { "initialize", &test_diff_drivers__initialize },
        { "cleanup", &test_diff_drivers__cleanup },
        _clar_cb_diff_drivers, 2, 1
    },
    {
        "diff::index",
        { "initialize", &test_diff_index__initialize },
        { "cleanup", &test_diff_index__cleanup },
        _clar_cb_diff_index, 3, 1
    },
    {
        "diff::iterator",
        { "initialize", &test_diff_iterator__initialize },
        { "cleanup", &test_diff_iterator__cleanup },
        _clar_cb_diff_iterator, 32, 1
    },
    {
        "diff::notify",
        { "initialize", &test_diff_notify__initialize },
        { "cleanup", &test_diff_notify__cleanup },
        _clar_cb_diff_notify, 6, 1
    },
    {
        "diff::patch",
        { "initialize", &test_diff_patch__initialize },
        { "cleanup", &test_diff_patch__cleanup },
        _clar_cb_diff_patch, 5, 1
    },
    {
        "diff::pathspec",
        { "initialize", &test_diff_pathspec__initialize },
        { "cleanup", &test_diff_pathspec__cleanup },
        _clar_cb_diff_pathspec, 1, 1
    },
    {
        "diff::rename",
        { "initialize", &test_diff_rename__initialize },
        { "cleanup", &test_diff_rename__cleanup },
        _clar_cb_diff_rename, 18, 1
    },
    {
        "diff::submodules",
        { "initialize", &test_diff_submodules__initialize },
        { "cleanup", &test_diff_submodules__cleanup },
        _clar_cb_diff_submodules, 7, 1
    },
    {
        "diff::tree",
        { "initialize", &test_diff_tree__initialize },
        { "cleanup", &test_diff_tree__cleanup },
        _clar_cb_diff_tree, 11, 1
    },
    {
        "diff::workdir",
        { "initialize", &test_diff_workdir__initialize },
        { "cleanup", &test_diff_workdir__cleanup },
        _clar_cb_diff_workdir, 21, 1
    },
    {
        "fetchhead::nonetwork",
        { "initialize", &test_fetchhead_nonetwork__initialize },
        { NULL, NULL },
        _clar_cb_fetchhead_nonetwork, 10, 1
    },
    {
        "filter::blob",
        { "initialize", &test_filter_blob__initialize },
        { "cleanup", &test_filter_blob__cleanup },
        _clar_cb_filter_blob, 2, 1
    },
    {
        "filter::crlf",
        { "initialize", &test_filter_crlf__initialize },
        { "cleanup", &test_filter_crlf__cleanup },
        _clar_cb_filter_crlf, 2, 1
    },
    {
        "filter::custom",
        { "initialize", &test_filter_custom__initialize },
        { "cleanup", &test_filter_custom__cleanup },
        _clar_cb_filter_custom, 5, 1
    },
    {
        "filter::ident",
        { "initialize", &test_filter_ident__initialize },
        { "cleanup", &test_filter_ident__cleanup },
        _clar_cb_filter_ident, 2, 1
    },
    {
        "index::addall",
        { "initialize", &test_index_addall__initialize },
        { "cleanup", &test_index_addall__cleanup },
        _clar_cb_index_addall, 1, 1
    },
    {
        "index::conflicts",
        { "initialize", &test_index_conflicts__initialize },
        { "cleanup", &test_index_conflicts__cleanup },
        _clar_cb_index_conflicts, 9, 1
    },
    {
        "index::filemodes",
        { "initialize", &test_index_filemodes__initialize },
        { "cleanup", &test_index_filemodes__cleanup },
        _clar_cb_index_filemodes, 3, 1
    },
    {
        "index::inmemory",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_index_inmemory, 2, 1
    },
    {
        "index::names",
        { "initialize", &test_index_names__initialize },
        { "cleanup", &test_index_names__cleanup },
        _clar_cb_index_names, 7, 1
    },
    {
        "index::read::tree",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_index_read_tree, 1, 1
    },
    {
        "index::rename",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_index_rename, 1, 1
    },
    {
        "index::reuc",
        { "initialize", &test_index_reuc__initialize },
        { "cleanup", &test_index_reuc__cleanup },
        _clar_cb_index_reuc, 14, 1
    },
    {
        "index::stage",
        { "initialize", &test_index_stage__initialize },
        { "cleanup", &test_index_stage__cleanup },
        _clar_cb_index_stage, 2, 1
    },
    {
        "index::tests",
        { "initialize", &test_index_tests__initialize },
        { NULL, NULL },
        _clar_cb_index_tests, 18, 1
    },
    {
        "merge::trees::automerge",
        { "initialize", &test_merge_trees_automerge__initialize },
        { "cleanup", &test_merge_trees_automerge__cleanup },
        _clar_cb_merge_trees_automerge, 4, 1
    },
    {
        "merge::trees::modeconflict",
        { "initialize", &test_merge_trees_modeconflict__initialize },
        { "cleanup", &test_merge_trees_modeconflict__cleanup },
        _clar_cb_merge_trees_modeconflict, 1, 1
    },
    {
        "merge::trees::renames",
        { "initialize", &test_merge_trees_renames__initialize },
        { "cleanup", &test_merge_trees_renames__cleanup },
        _clar_cb_merge_trees_renames, 2, 1
    },
    {
        "merge::trees::treediff",
        { "initialize", &test_merge_trees_treediff__initialize },
        { "cleanup", &test_merge_trees_treediff__cleanup },
        _clar_cb_merge_trees_treediff, 5, 1
    },
    {
        "merge::trees::trivial",
        { "initialize", &test_merge_trees_trivial__initialize },
        { "cleanup", &test_merge_trees_trivial__cleanup },
        _clar_cb_merge_trees_trivial, 18, 1
    },
    {
        "merge::workdir::fastforward",
        { "initialize", &test_merge_workdir_fastforward__initialize },
        { "cleanup", &test_merge_workdir_fastforward__cleanup },
        _clar_cb_merge_workdir_fastforward, 5, 1
    },
    {
        "merge::workdir::renames",
        { "initialize", &test_merge_workdir_renames__initialize },
        { "cleanup", &test_merge_workdir_renames__cleanup },
        _clar_cb_merge_workdir_renames, 3, 1
    },
    {
        "merge::workdir::setup",
        { "initialize", &test_merge_workdir_setup__initialize },
        { "cleanup", &test_merge_workdir_setup__cleanup },
        _clar_cb_merge_workdir_setup, 30, 1
    },
    {
        "merge::workdir::simple",
        { "initialize", &test_merge_workdir_simple__initialize },
        { "cleanup", &test_merge_workdir_simple__cleanup },
        _clar_cb_merge_workdir_simple, 9, 1
    },
    {
        "merge::workdir::trivial",
        { "initialize", &test_merge_workdir_trivial__initialize },
        { "cleanup", &test_merge_workdir_trivial__cleanup },
        _clar_cb_merge_workdir_trivial, 18, 1
    },
    {
        "network::cred",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_network_cred, 3, 1
    },
    {
        "network::fetchlocal",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_network_fetchlocal, 2, 1
    },
    {
        "network::refspecs",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_network_refspecs, 1, 1
    },
    {
        "network::remote::createthenload",
        { "initialize", &test_network_remote_createthenload__initialize },
        { "cleanup", &test_network_remote_createthenload__cleanup },
        _clar_cb_network_remote_createthenload, 1, 1
    },
    {
        "network::remote::isvalidname",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_network_remote_isvalidname, 2, 1
    },
    {
        "network::remote::local",
        { "initialize", &test_network_remote_local__initialize },
        { "cleanup", &test_network_remote_local__cleanup },
        _clar_cb_network_remote_local, 10, 1
    },
    {
        "network::remote::remotes",
        { "initialize", &test_network_remote_remotes__initialize },
        { "cleanup", &test_network_remote_remotes__cleanup },
        _clar_cb_network_remote_remotes, 31, 1
    },
    {
        "network::remote::rename",
        { "initialize", &test_network_remote_rename__initialize },
        { "cleanup", &test_network_remote_rename__cleanup },
        _clar_cb_network_remote_rename, 11, 1
    },
    {
        "network::urlparse",
        { "initialize", &test_network_urlparse__initialize },
        { "cleanup", &test_network_urlparse__cleanup },
        _clar_cb_network_urlparse, 15, 1
    },
    {
        "notes::notes",
        { "initialize", &test_notes_notes__initialize },
        { "cleanup", &test_notes_notes__cleanup },
        _clar_cb_notes_notes, 14, 1
    },
    {
        "notes::notesref",
        { "initialize", &test_notes_notesref__initialize },
        { "cleanup", &test_notes_notesref__cleanup },
        _clar_cb_notes_notesref, 1, 1
    },
    {
        "object::blob::filter",
        { "initialize", &test_object_blob_filter__initialize },
        { "cleanup", &test_object_blob_filter__cleanup },
        _clar_cb_object_blob_filter, 3, 1
    },
    {
        "object::blob::fromchunks",
        { "initialize", &test_object_blob_fromchunks__initialize },
        { "cleanup", &test_object_blob_fromchunks__cleanup },
        _clar_cb_object_blob_fromchunks, 3, 1
    },
    {
        "object::blob::write",
        { NULL, NULL },
        { "cleanup", &test_object_blob_write__cleanup },
        _clar_cb_object_blob_write, 3, 1
    },
    {
        "object::cache",
        { "initialize", &test_object_cache__initialize },
        { "cleanup", &test_object_cache__cleanup },
        _clar_cb_object_cache, 4, 1
    },
    {
        "object::commit::commitstagedfile",
        { "initialize", &test_object_commit_commitstagedfile__initialize },
        { "cleanup", &test_object_commit_commitstagedfile__cleanup },
        _clar_cb_object_commit_commitstagedfile, 1, 1
    },
    {
        "object::lookup",
        { "initialize", &test_object_lookup__initialize },
        { "cleanup", &test_object_lookup__cleanup },
        _clar_cb_object_lookup, 4, 1
    },
    {
        "object::lookupbypath",
        { "initialize", &test_object_lookupbypath__initialize },
        { "cleanup", &test_object_lookupbypath__cleanup },
        _clar_cb_object_lookupbypath, 4, 1
    },
    {
        "object::message",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_message, 16, 1
    },
    {
        "object::peel",
        { "initialize", &test_object_peel__initialize },
        { "cleanup", &test_object_peel__cleanup },
        _clar_cb_object_peel, 6, 1
    },
    {
        "object::raw::chars",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_chars, 2, 1
    },
    {
        "object::raw::compare",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_compare, 7, 1
    },
    {
        "object::raw::convert",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_convert, 3, 1
    },
    {
        "object::raw::fromstr",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_fromstr, 2, 1
    },
    {
        "object::raw::hash",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_hash, 11, 1
    },
    {
        "object::raw::short",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_short, 3, 1
    },
    {
        "object::raw::size",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_size, 1, 1
    },
    {
        "object::raw::type2string",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_type2string, 3, 1
    },
    {
        "object::raw::write",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_write, 7, 1
    },
    {
        "object::tag::list",
        { "initialize", &test_object_tag_list__initialize },
        { "cleanup", &test_object_tag_list__cleanup },
        _clar_cb_object_tag_list, 2, 1
    },
    {
        "object::tag::peel",
        { "initialize", &test_object_tag_peel__initialize },
        { "cleanup", &test_object_tag_peel__cleanup },
        _clar_cb_object_tag_peel, 3, 1
    },
    {
        "object::tag::read",
        { "initialize", &test_object_tag_read__initialize },
        { "cleanup", &test_object_tag_read__cleanup },
        _clar_cb_object_tag_read, 4, 1
    },
    {
        "object::tag::write",
        { "initialize", &test_object_tag_write__initialize },
        { "cleanup", &test_object_tag_write__cleanup },
        _clar_cb_object_tag_write, 10, 1
    },
    {
        "object::tree::attributes",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_tree_attributes, 5, 1
    },
    {
        "object::tree::duplicateentries",
        { "initialize", &test_object_tree_duplicateentries__initialize },
        { "cleanup", &test_object_tree_duplicateentries__cleanup },
        _clar_cb_object_tree_duplicateentries, 2, 1
    },
    {
        "object::tree::frompath",
        { "initialize", &test_object_tree_frompath__initialize },
        { "cleanup", &test_object_tree_frompath__cleanup },
        _clar_cb_object_tree_frompath, 2, 1
    },
    {
        "object::tree::read",
        { "initialize", &test_object_tree_read__initialize },
        { "cleanup", &test_object_tree_read__cleanup },
        _clar_cb_object_tree_read, 2, 1
    },
    {
        "object::tree::walk",
        { "initialize", &test_object_tree_walk__initialize },
        { "cleanup", &test_object_tree_walk__cleanup },
        _clar_cb_object_tree_walk, 3, 1
    },
    {
        "object::tree::write",
        { "initialize", &test_object_tree_write__initialize },
        { "cleanup", &test_object_tree_write__cleanup },
        _clar_cb_object_tree_write, 4, 1
    },
    {
        "odb::alternates",
        { NULL, NULL },
        { "cleanup", &test_odb_alternates__cleanup },
        _clar_cb_odb_alternates, 2, 1
    },
    {
        "odb::backend::nonrefreshing",
        { NULL, NULL },
        { "cleanup", &test_odb_backend_nonrefreshing__cleanup },
        _clar_cb_odb_backend_nonrefreshing, 9, 1
    },
    {
        "odb::foreach",
        { NULL, NULL },
        { "cleanup", &test_odb_foreach__cleanup },
        _clar_cb_odb_foreach, 3, 1
    },
    {
        "odb::loose",
        { "initialize", &test_odb_loose__initialize },
        { "cleanup", &test_odb_loose__cleanup },
        _clar_cb_odb_loose, 4, 1
    },
    {
        "odb::mixed",
        { "initialize", &test_odb_mixed__initialize },
        { "cleanup", &test_odb_mixed__cleanup },
        _clar_cb_odb_mixed, 2, 1
    },
    {
        "odb::packed",
        { "initialize", &test_odb_packed__initialize },
        { "cleanup", &test_odb_packed__cleanup },
        _clar_cb_odb_packed, 3, 1
    },
    {
        "odb::packed::one",
        { "initialize", &test_odb_packed_one__initialize },
        { "cleanup", &test_odb_packed_one__cleanup },
        _clar_cb_odb_packed_one, 2, 1
    },
    {
        "odb::sorting",
        { "initialize", &test_odb_sorting__initialize },
        { "cleanup", &test_odb_sorting__cleanup },
        _clar_cb_odb_sorting, 2, 1
    },
    {
        "odb::streamwrite",
        { "initialize", &test_odb_streamwrite__initialize },
        { "cleanup", &test_odb_streamwrite__cleanup },
        _clar_cb_odb_streamwrite, 3, 1
    },
    {
        "online::clone",
        { "initialize", &test_online_clone__initialize },
        { "cleanup", &test_online_clone__cleanup },
        _clar_cb_online_clone, 11, 1
    },
    {
        "online::fetch",
        { "initialize", &test_online_fetch__initialize },
        { "cleanup", &test_online_fetch__cleanup },
        _clar_cb_online_fetch, 8, 1
    },
    {
        "online::fetchhead",
        { "initialize", &test_online_fetchhead__initialize },
        { "cleanup", &test_online_fetchhead__cleanup },
        _clar_cb_online_fetchhead, 3, 1
    },
    {
        "online::push",
        { "initialize", &test_online_push__initialize },
        { "cleanup", &test_online_push__cleanup },
        _clar_cb_online_push, 19, 1
    },
    {
        "pack::indexer",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_pack_indexer, 2, 1
    },
    {
        "pack::packbuilder",
        { "initialize", &test_pack_packbuilder__initialize },
        { "cleanup", &test_pack_packbuilder__cleanup },
        _clar_cb_pack_packbuilder, 6, 1
    },
    {
        "refs::branches::create",
        { "initialize", &test_refs_branches_create__initialize },
        { "cleanup", &test_refs_branches_create__cleanup },
        _clar_cb_refs_branches_create, 4, 1
    },
    {
        "refs::branches::delete",
        { "initialize", &test_refs_branches_delete__initialize },
        { "cleanup", &test_refs_branches_delete__cleanup },
        _clar_cb_refs_branches_delete, 7, 1
    },
    {
        "refs::branches::ishead",
        { "initialize", &test_refs_branches_ishead__initialize },
        { "cleanup", &test_refs_branches_ishead__cleanup },
        _clar_cb_refs_branches_ishead, 6, 1
    },
    {
        "refs::branches::iterator",
        { "initialize", &test_refs_branches_iterator__initialize },
        { "cleanup", &test_refs_branches_iterator__cleanup },
        _clar_cb_refs_branches_iterator, 5, 1
    },
    {
        "refs::branches::lookup",
        { "initialize", &test_refs_branches_lookup__initialize },
        { "cleanup", &test_refs_branches_lookup__cleanup },
        _clar_cb_refs_branches_lookup, 4, 1
    },
    {
        "refs::branches::move",
        { "initialize", &test_refs_branches_move__initialize },
        { "cleanup", &test_refs_branches_move__cleanup },
        _clar_cb_refs_branches_move, 9, 1
    },
    {
        "refs::branches::name",
        { "initialize", &test_refs_branches_name__initialize },
        { "cleanup", &test_refs_branches_name__cleanup },
        _clar_cb_refs_branches_name, 3, 1
    },
    {
        "refs::branches::remote",
        { "initialize", &test_refs_branches_remote__initialize },
        { "cleanup", &test_refs_branches_remote__cleanup },
        _clar_cb_refs_branches_remote, 5, 1
    },
    {
        "refs::branches::upstream",
        { "initialize", &test_refs_branches_upstream__initialize },
        { "cleanup", &test_refs_branches_upstream__cleanup },
        _clar_cb_refs_branches_upstream, 7, 1
    },
    {
        "refs::branches::upstreamname",
        { "initialize", &test_refs_branches_upstreamname__initialize },
        { "cleanup", &test_refs_branches_upstreamname__cleanup },
        _clar_cb_refs_branches_upstreamname, 3, 1
    },
    {
        "refs::crashes",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_crashes, 1, 1
    },
    {
        "refs::create",
        { "initialize", &test_refs_create__initialize },
        { "cleanup", &test_refs_create__cleanup },
        _clar_cb_refs_create, 6, 1
    },
    {
        "refs::delete",
        { "initialize", &test_refs_delete__initialize },
        { "cleanup", &test_refs_delete__cleanup },
        _clar_cb_refs_delete, 2, 1
    },
    {
        "refs::foreachglob",
        { "initialize", &test_refs_foreachglob__initialize },
        { "cleanup", &test_refs_foreachglob__cleanup },
        _clar_cb_refs_foreachglob, 5, 1
    },
    {
        "refs::isvalidname",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_isvalidname, 2, 1
    },
    {
        "refs::iterator",
        { "initialize", &test_refs_iterator__initialize },
        { "cleanup", &test_refs_iterator__cleanup },
        _clar_cb_refs_iterator, 2, 1
    },
    {
        "refs::list",
        { "initialize", &test_refs_list__initialize },
        { "cleanup", &test_refs_list__cleanup },
        _clar_cb_refs_list, 2, 1
    },
    {
        "refs::listall",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_listall, 3, 1
    },
    {
        "refs::lookup",
        { "initialize", &test_refs_lookup__initialize },
        { "cleanup", &test_refs_lookup__cleanup },
        _clar_cb_refs_lookup, 4, 1
    },
    {
        "refs::normalize",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_normalize, 6, 1
    },
    {
        "refs::overwrite",
        { "initialize", &test_refs_overwrite__initialize },
        { "cleanup", &test_refs_overwrite__cleanup },
        _clar_cb_refs_overwrite, 4, 1
    },
    {
        "refs::pack",
        { "initialize", &test_refs_pack__initialize },
        { "cleanup", &test_refs_pack__cleanup },
        _clar_cb_refs_pack, 3, 1
    },
    {
        "refs::peel",
        { "initialize", &test_refs_peel__initialize },
        { "cleanup", &test_refs_peel__cleanup },
        _clar_cb_refs_peel, 6, 1
    },
    {
        "refs::read",
        { "initialize", &test_refs_read__initialize },
        { "cleanup", &test_refs_read__cleanup },
        _clar_cb_refs_read, 14, 1
    },
    {
        "refs::reflog::drop",
        { "initialize", &test_refs_reflog_drop__initialize },
        { "cleanup", &test_refs_reflog_drop__cleanup },
        _clar_cb_refs_reflog_drop, 7, 1
    },
    {
        "refs::reflog::reflog",
        { "initialize", &test_refs_reflog_reflog__initialize },
        { "cleanup", &test_refs_reflog_reflog__cleanup },
        _clar_cb_refs_reflog_reflog, 7, 1
    },
    {
        "refs::rename",
        { "initialize", &test_refs_rename__initialize },
        { "cleanup", &test_refs_rename__cleanup },
        _clar_cb_refs_rename, 11, 1
    },
    {
        "refs::revparse",
        { "initialize", &test_refs_revparse__initialize },
        { "cleanup", &test_refs_revparse__cleanup },
        _clar_cb_refs_revparse, 32, 1
    },
    {
        "refs::setter",
        { "initialize", &test_refs_setter__initialize },
        { "cleanup", &test_refs_setter__cleanup },
        _clar_cb_refs_setter, 4, 1
    },
    {
        "refs::shorthand",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_shorthand, 1, 1
    },
    {
        "refs::unicode",
        { "initialize", &test_refs_unicode__initialize },
        { "cleanup", &test_refs_unicode__cleanup },
        _clar_cb_refs_unicode, 1, 1
    },
    {
        "refs::update",
        { "initialize", &test_refs_update__initialize },
        { "cleanup", &test_refs_update__cleanup },
        _clar_cb_refs_update, 1, 1
    },
    {
        "repo::config",
        { "initialize", &test_repo_config__initialize },
        { "cleanup", &test_repo_config__cleanup },
        _clar_cb_repo_config, 3, 1
    },
    {
        "repo::discover",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_repo_discover, 1, 1
    },
    {
        "repo::getters",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_repo_getters, 3, 1
    },
    {
        "repo::hashfile",
        { "initialize", &test_repo_hashfile__initialize },
        { "cleanup", &test_repo_hashfile__cleanup },
        _clar_cb_repo_hashfile, 2, 1
    },
    {
        "repo::head",
        { "initialize", &test_repo_head__initialize },
        { "cleanup", &test_repo_head__cleanup },
        _clar_cb_repo_head, 16, 1
    },
    {
        "repo::headtree",
        { "initialize", &test_repo_headtree__initialize },
        { "cleanup", &test_repo_headtree__cleanup },
        _clar_cb_repo_headtree, 4, 1
    },
    {
        "repo::init",
        { "initialize", &test_repo_init__initialize },
        { NULL, NULL },
        _clar_cb_repo_init, 20, 1
    },
    {
        "repo::iterator",
        { "initialize", &test_repo_iterator__initialize },
        { "cleanup", &test_repo_iterator__cleanup },
        _clar_cb_repo_iterator, 14, 1
    },
    {
        "repo::message",
        { "initialize", &test_repo_message__initialize },
        { "cleanup", &test_repo_message__cleanup },
        _clar_cb_repo_message, 2, 1
    },
    {
        "repo::open",
        { NULL, NULL },
        { "cleanup", &test_repo_open__cleanup },
        _clar_cb_repo_open, 12, 1
    },
    {
        "repo::pathspec",
        { "initialize", &test_repo_pathspec__initialize },
        { "cleanup", &test_repo_pathspec__cleanup },
        _clar_cb_repo_pathspec, 10, 1
    },
    {
        "repo::setters",
        { "initialize", &test_repo_setters__initialize },
        { "cleanup", &test_repo_setters__cleanup },
        _clar_cb_repo_setters, 5, 1
    },
    {
        "repo::shallow",
        { "initialize", &test_repo_shallow__initialize },
        { "cleanup", &test_repo_shallow__cleanup },
        _clar_cb_repo_shallow, 3, 1
    },
    {
        "repo::state",
        { "initialize", &test_repo_state__initialize },
        { "cleanup", &test_repo_state__cleanup },
        _clar_cb_repo_state, 11, 1
    },
    {
        "reset::default",
        { "initialize", &test_reset_default__initialize },
        { "cleanup", &test_reset_default__cleanup },
        _clar_cb_reset_default, 4, 1
    },
    {
        "reset::hard",
        { "initialize", &test_reset_hard__initialize },
        { "cleanup", &test_reset_hard__cleanup },
        _clar_cb_reset_hard, 4, 1
    },
    {
        "reset::mixed",
        { "initialize", &test_reset_mixed__initialize },
        { "cleanup", &test_reset_mixed__cleanup },
        _clar_cb_reset_mixed, 2, 1
    },
    {
        "reset::soft",
        { "initialize", &test_reset_soft__initialize },
        { "cleanup", &test_reset_soft__cleanup },
        _clar_cb_reset_soft, 8, 1
    },
    {
        "revwalk::basic",
        { "initialize", &test_revwalk_basic__initialize },
        { "cleanup", &test_revwalk_basic__cleanup },
        _clar_cb_revwalk_basic, 8, 1
    },
    {
        "revwalk::mergebase",
        { "initialize", &test_revwalk_mergebase__initialize },
        { "cleanup", &test_revwalk_mergebase__cleanup },
        _clar_cb_revwalk_mergebase, 9, 1
    },
    {
        "revwalk::signatureparsing",
        { "initialize", &test_revwalk_signatureparsing__initialize },
        { "cleanup", &test_revwalk_signatureparsing__cleanup },
        _clar_cb_revwalk_signatureparsing, 1, 1
    },
    {
        "revwalk::simplify",
        { NULL, NULL },
        { "cleanup", &test_revwalk_simplify__cleanup },
        _clar_cb_revwalk_simplify, 1, 1
    },
    {
        "stash::drop",
        { "initialize", &test_stash_drop__initialize },
        { "cleanup", &test_stash_drop__cleanup },
        _clar_cb_stash_drop, 7, 1
    },
    {
        "stash::foreach",
        { "initialize", &test_stash_foreach__initialize },
        { "cleanup", &test_stash_foreach__cleanup },
        _clar_cb_stash_foreach, 2, 1
    },
    {
        "stash::save",
        { "initialize", &test_stash_save__initialize },
        { "cleanup", &test_stash_save__cleanup },
        _clar_cb_stash_save, 12, 1
    },
    {
        "stash::submodules",
        { "initialize", &test_stash_submodules__initialize },
        { "cleanup", &test_stash_submodules__cleanup },
        _clar_cb_stash_submodules, 2, 1
    },
    {
        "status::ignore",
        { "initialize", &test_status_ignore__initialize },
        { "cleanup", &test_status_ignore__cleanup },
        _clar_cb_status_ignore, 13, 1
    },
    {
        "status::renames",
        { "initialize", &test_status_renames__initialize },
        { "cleanup", &test_status_renames__cleanup },
        _clar_cb_status_renames, 13, 1
    },
    {
        "status::single",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_status_single, 2, 1
    },
    {
        "status::submodules",
        { "initialize", &test_status_submodules__initialize },
        { "cleanup", &test_status_submodules__cleanup },
        _clar_cb_status_submodules, 6, 1
    },
    {
        "status::worktree",
        { NULL, NULL },
        { "cleanup", &test_status_worktree__cleanup },
        _clar_cb_status_worktree, 34, 1
    },
    {
        "status::worktree::init",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_status_worktree_init, 8, 1
    },
    {
        "stress::diff",
        { "initialize", &test_stress_diff__initialize },
        { "cleanup", &test_stress_diff__cleanup },
        _clar_cb_stress_diff, 2, 0
    },
    {
        "submodule::lookup",
        { "initialize", &test_submodule_lookup__initialize },
        { NULL, NULL },
        _clar_cb_submodule_lookup, 5, 1
    },
    {
        "submodule::modify",
        { "initialize", &test_submodule_modify__initialize },
        { NULL, NULL },
        _clar_cb_submodule_modify, 4, 1
    },
    {
        "submodule::status",
        { "initialize", &test_submodule_status__initialize },
        { "cleanup", &test_submodule_status__cleanup },
        _clar_cb_submodule_status, 7, 1
    },
    {
        "threads::basic",
        { "initialize", &test_threads_basic__initialize },
        { "cleanup", &test_threads_basic__cleanup },
        _clar_cb_threads_basic, 2, 1
    },
    {
        "threads::refdb",
        { "initialize", &test_threads_refdb__initialize },
        { "cleanup", &test_threads_refdb__cleanup },
        _clar_cb_threads_refdb, 2, 1
    },
    {
        "trace::trace",
        { "initialize", &test_trace_trace__initialize },
        { "cleanup", &test_trace_trace__cleanup },
        _clar_cb_trace_trace, 6, 1
    }
};
static const size_t _clar_suite_count = 224;
static const size_t _clar_callback_count = 1385;
